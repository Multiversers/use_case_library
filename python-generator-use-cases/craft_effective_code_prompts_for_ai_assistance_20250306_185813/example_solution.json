{
  "content": "{\n  \"metadata\": {\n    \"id\": \"CORE-02\",\n    \"ai_tool\": \"GitHub Copilot\",\n    \"family\": \"Core Skills\",\n    \"status\": \"active\",\n    \"complexity_level\": \"Intermediate\",\n    \"customization_level\": \"Standard\",\n    \"time_minutes\": 20,\n    \"department\": [\n      \"SWE\"\n    ],\n    \"role\": [\n      \"front-end\"\n    ],\n    \"notes\": \"This solution demonstrates effective code prompting in an inline chat environment using GitHub Copilot with GPT-4o.\",\n    \"tool\": \"GitHub Copilot\",\n    \"mode\": \"inline chat\",\n    \"model\": \"GPT-4o\",\n    \"coding_language\": \"Python\"\n  },\n  \"solution\": {\n    \"title\": \"Craft Effective Code Prompts for AI Assistance\",\n    \"setup_time\": 3,\n    \"demo_time\": 3,\n    \"prerequisites\": [\n      \"Writing clear code comments\",\n      \"Understanding code structure\",\n      \"Basic algorithmic thinking\",\n      \"Familiarity with code completion tools\",\n      \"Basic understanding of natural language processing\"\n    ],\n    \"scenario\": \"A front-end developer utilizes GitHub Copilot in inline chat mode powered by GPT-4o to iteratively generate and improve Python code. The developer writes detailed docstrings, adds specific TODO comments, clearly explains complex logic in plain language, refines prompts based on initial outputs, and validates the final code through testing.\",\n    \"steps\": [\n      {\n        \"action\": \"Write detailed function docstring: Compose a comprehensive Python function docstring that details the function's purpose, parameters, return values, and usage examples to guide the AI.\",\n        \"code_or_prompt\": \"def calculate_discounted_price(price, discount):\\n    \\\"\\\"\\\"\\n    Calculate the final price after applying a discount.\\n\\n    Parameters:\\n        price (float): The original price of the item. Must be non-negative.\\n        discount (float): Discount rate as a float between 0 and 1 (e.g., 0.20 for 20% discount).\\n\\n    Returns:\\n        float: Final price after discount. Returns 0 if discount is 1.\\n\\n    Example:\\n        >>> calculate_discounted_price(100.0, 0.2)\\n        80.0\\n    \\\"\\\"\\\"\\n    return price * (1 - discount)\"\n      },\n      {\n        \"action\": \"Add specific TODO comments: Insert inline TODO comments that clearly outline specific algorithmic tasks and constraints.\",\n        \"code_or_prompt\": \"def fetch_user_data(user_id: int) -> dict:\\n    \\\"\\\"\\\"Fetch user data from the database using a unique user ID.\\\"\\\"\\\"\\n    # TODO: Establish a secure connection to the user database\\n    # TODO: Execute an SQL query to retrieve user details\\n    # TODO: Implement error handling for connection timeouts and query failures\\n    # TODO: Validate the format of the returned data\\n    return {}\"\n      },\n      {\n        \"action\": \"Describe complex logic in natural language: Explain the detailed logic behind a function in plain language to ensure clarity before implementation.\",\n        \"code_or_prompt\": \"def sort_numbers(numbers: list) -> list:\\n    \\\"\\\"\\\"Sort a list of numbers using the merge sort algorithm.\\\"\\\"\\\"\\n    # The merge sort algorithm works as follows:\\n    # 1. If the list has zero or one element, it is already sorted.\\n    # 2. Divide the list into two nearly equal halves.\\n    # 3. Recursively sort each half.\\n    # 4. Merge the two sorted halves by comparing the smallest elements from each.\\n    # 5. Return the fully merged and sorted list.\\n    if len(numbers) <= 1:\\n        return numbers\\n    mid = len(numbers) // 2\\n    left = sort_numbers(numbers[:mid])\\n    right = sort_numbers(numbers[mid:])\\n    sorted_list = []\\n    i = j = 0\\n    while i < len(left) and j < len(right):\\n        if left[i] < right[j]:\\n            sorted_list.append(left[i])\\n            i += 1\\n        else:\\n            sorted_list.append(right[j])\\n            j += 1\\n    sorted_list.extend(left[i:])\\n    sorted_list.extend(right[j:])\\n    return sorted_list\"\n      },\n      {\n        \"action\": \"Refine your prompts based on initial output: Review the AI-generated code and adjust your prompts with added clarifications for error handling and edge cases.\",\n        \"code_or_prompt\": \"# Initial review of the fetch_user_data function revealed missing input validation and error handling for invalid user IDs.\\n# Refined prompt for GitHub Copilot:\\n\\\"@copilot, update the fetch_user_data function to include validation that the user_id is a positive integer and add try-except blocks to handle potential database errors.\\\"\"\n      },\n      {\n        \"action\": \"Validate the generated code: Test and review the code to ensure it meets functional requirements and handles edge cases appropriately.\",\n        \"code_or_prompt\": \"if __name__ == '__main__':\\n    # Validate calculate_discounted_price function\\n    result = calculate_discounted_price(100.0, 0.2)\\n    print('Discounted Price:', result)  # Expected output: 80.0\\n\\n    # Validate sort_numbers function\\n    test_numbers = [34, 7, 23, 32, 5, 62]\\n    sorted_numbers = sort_numbers(test_numbers)\\n    print('Sorted Numbers:', sorted_numbers)  # Expected sorted list: [5, 7, 23, 32, 34, 62]\\n\\n    # Further testing and manual code review should be performed to ensure all edge cases and error handling are in place.\"\n      }\n    ],\n    \"validation\": [\n      \"Run the main block to verify the expected outputs for each function.\",\n      \"Inspect inline comments and TODO items to confirm they guide the AI effectively.\",\n      \"Verify that GitHub Copilot's refined suggestions address initial shortcomings.\",\n      \"Conduct manual code reviews and run unit tests to cover error handling and edge cases.\"\n    ],\n    \"key_points\": [\n      \"Craft clear and comprehensive docstrings as effective AI prompts.\",\n      \"Include specific and actionable TODO comments.\",\n      \"Describe complex logic in plain natural language.\",\n      \"Iteratively refine prompts based on AI output feedback.\",\n      \"Validate generated code through thorough testing and reviews.\"\n    ],\n    \"common_issues\": [\n      \"Ambiguous prompts may not capture all functional requirements.\",\n      \"Overreliance on auto-generated code without manual validation.\",\n      \"Insufficient error handling or unclear TODO instructions.\",\n      \"Missing detailed inline explanations can reduce code clarity.\"\n    ],\n    \"variations\": []\n  },\n  \"demo_script\": \"Welcome to this demo on crafting effective code prompts for AI assistance using GitHub Copilot with GPT-4o. In this 2-3 minute walkthrough, you'll see how to start by writing a detailed function docstring that defines a function's purpose, parameters, and return values. Next, you'll add specific TODO comments that precisely outline each task and constraint. We'll then describe complex logic in plain language to guide the AI in generating robust code. After reviewing the initial output from Copilot, you'll refine your prompts to handle edge cases and improve error handling. Finally, you'll validate the generated code by running tests and reviewing the outputs to ensure everything meets your requirements. Follow along with the provided Python examples to reproduce this process in your own projects.\"\n}"
}