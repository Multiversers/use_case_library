2025-03-06 18:58:13,750 - INFO - 
Started job: craft_effective_code_prompts_for_ai_assistance_20250306_185813
2025-03-06 18:58:13,750 - INFO - 
Loaded use case CORE-02
2025-03-06 18:58:13,750 - INFO - 
================================================================================
2025-03-06 18:58:13,750 - INFO - INITIATING STEP: 1 - Identify Research Questions
2025-03-06 18:58:13,750 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:13,750 - INFO - FULL PROMPT:
2025-03-06 18:58:13,750 - INFO - ----------------------------------------
2025-03-06 18:58:13,750 - INFO - [system]
2025-03-06 18:58:13,750 - INFO - You are an AI researcher tasked with generating research questions for a software development use case. Your questions will be processed independently by another AI system to gather comprehensive information.

CRITICAL REQUIREMENTS FOR QUESTION GENERATION:

1. CONTENT INTEGRATION:
   - Extract and incorporate key technical elements from the use case (tools, models, languages, etc.)
   - Include specific version numbers, frameworks, or technologies when mentioned
   - Reference any unique methodologies or approaches specified

2. QUESTION STRUCTURE:
   - Each question must be fully self-contained with sufficient context
   - Focus on distinct aspects or subtopics
   - Include relevant technical terms and industry standards

3. COVERAGE REQUIREMENTS:
   - At least one question must focus on tool-specific capabilities or features, if provided
   - At least one question must address best practices or common pitfalls
   - If specific models/versions are mentioned, include version-specific research

4. SCOPE AND SPECIFICITY:
   - Questions should be specific enough to yield actionable insights
   - Include temporal context (e.g., 'current best practices', 'latest features')
   - Reference any relevant prerequisites or dependencies

FORMAT REQUIREMENTS:
- Generate exactly 2-4 questions
- One question per line
- No numbering or prefixes
- Each question should be a complete, well-formed research query

2025-03-06 18:58:13,750 - INFO - ----------------------------------------
2025-03-06 18:58:13,750 - INFO - [user]
2025-03-06 18:58:13,750 - INFO - Generate research questions for this use case:


<Use_Case_ID>CORE-02</Use_Case_ID>
<Use_Case>Craft Effective Code Prompts for AI Assistance</Use_Case>
<Family>Core Skills</Family>
<AI_Tool>Coding Assistants</AI_Tool>
<Objective>Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation</Objective>
<Description>This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.</Description>
<Prerequisites>
- Writing clear code comments
- Understanding code structure
- Basic algorithmic thinking
- Familiarity with code completion tools
- Basic understanding of natural language processing
</Prerequisites>
<Time_Estimate>20 minutes</Time_Estimate>
<Steps>
- Write a detailed function description in docstring format
- Add TODO comments with specific algorithm requirements
- Use natural language to describe complex logic before implementation
- Refine prompts based on initial AI outputs
- Validate generated code against original intent
</Steps>
<Tool>GitHub Copilot</Tool>
<Department>SWE</Department>
<Role>front-end</Role>
<Mode>inline chat</Mode>
<Model>GPT-4o</Model>
<Coding_Language>Python</Coding_Language>

2025-03-06 18:58:13,750 - INFO - ----------------------------------------
2025-03-06 18:58:13,750 - INFO - ================================================================================

2025-03-06 18:58:19,997 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-03-06 18:58:20,005 - INFO - 
================================================================================
2025-03-06 18:58:20,005 - INFO - STEP: 1 - Identify Research Questions
2025-03-06 18:58:20,005 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:20,005 - INFO - PROMPT:
2025-03-06 18:58:20,005 - INFO - ----------------------------------------
2025-03-06 18:58:20,005 - INFO - Generate research questions for this use case:


<Use_Case_ID>CORE-02</Use_Case_ID>
<Use_Case>Craft Effective Code Prompts for AI Assistance</Use_Case>
<Family>Core Skills</Family>
<AI_Tool>Coding Assistants</AI_Tool>
<Objective>Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation</Objective>
<Description>This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.</Description>
<Prerequisites>
- Writing clear code comments
- Understanding code structure
- Basic algorithmic thinking
- Familiarity with code completion tools
- Basic understanding of natural language processing
</Prerequisites>
<Time_Estimate>20 minutes</Time_Estimate>
<Steps>
- Write a detailed function description in docstring format
- Add TODO comments with specific algorithm requirements
- Use natural language to describe complex logic before implementation
- Refine prompts based on initial AI outputs
- Validate generated code against original intent
</Steps>
<Tool>GitHub Copilot</Tool>
<Department>SWE</Department>
<Role>front-end</Role>
<Mode>inline chat</Mode>
<Model>GPT-4o</Model>
<Coding_Language>Python</Coding_Language>

2025-03-06 18:58:20,005 - INFO - ----------------------------------------
2025-03-06 18:58:20,005 - INFO - RESPONSE:
2025-03-06 18:58:20,005 - INFO - ----------------------------------------
2025-03-06 18:58:20,005 - INFO - How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?
What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?
In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?
2025-03-06 18:58:20,005 - INFO - ================================================================================

2025-03-06 18:58:20,006 - INFO - 
Completed step 1: Identified research questions
['How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?', 'What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?', 'In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?']
2025-03-06 18:58:20,007 - INFO - 
================================================================================
2025-03-06 18:58:20,007 - INFO - INITIATING STEP: 2 - Deep Research (Single Question)
2025-03-06 18:58:20,007 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:20,007 - INFO - FULL PROMPT:
2025-03-06 18:58:20,007 - INFO - ----------------------------------------
2025-03-06 18:58:20,007 - INFO - [system]
2025-03-06 18:58:20,007 - INFO - You are a specialized AI for research, providing relevant info for educational content creation. Format your response to be directly usable in educational materials about AI technologies and software development practices. Include specific examples, code samples when relevant, and cite recent sources.
2025-03-06 18:58:20,007 - INFO - ----------------------------------------
2025-03-06 18:58:20,007 - INFO - [user]
2025-03-06 18:58:20,007 - INFO - I'm researching for a use case titled 'Craft Effective Code Prompts for AI Assistance' in the category 'Core Skills'. The objective is: 'Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation'. This is for creating developer educational content about AI skills. How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?
2025-03-06 18:58:20,007 - INFO - ----------------------------------------
2025-03-06 18:58:20,007 - INFO - ================================================================================

2025-03-06 18:58:20,011 - INFO - 
================================================================================
2025-03-06 18:58:20,012 - INFO - INITIATING STEP: 2 - Deep Research (Single Question)
2025-03-06 18:58:20,012 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:20,012 - INFO - FULL PROMPT:
2025-03-06 18:58:20,012 - INFO - ----------------------------------------
2025-03-06 18:58:20,012 - INFO - [system]
2025-03-06 18:58:20,012 - INFO - You are a specialized AI for research, providing relevant info for educational content creation. Format your response to be directly usable in educational materials about AI technologies and software development practices. Include specific examples, code samples when relevant, and cite recent sources.
2025-03-06 18:58:20,012 - INFO - ----------------------------------------
2025-03-06 18:58:20,012 - INFO - [user]
2025-03-06 18:58:20,012 - INFO - I'm researching for a use case titled 'Craft Effective Code Prompts for AI Assistance' in the category 'Core Skills'. The objective is: 'Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation'. This is for creating developer educational content about AI skills. What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?
2025-03-06 18:58:20,013 - INFO - ----------------------------------------
2025-03-06 18:58:20,013 - INFO - ================================================================================

2025-03-06 18:58:20,016 - INFO - 
================================================================================
2025-03-06 18:58:20,016 - INFO - INITIATING STEP: 2 - Deep Research (Single Question)
2025-03-06 18:58:20,016 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:20,016 - INFO - FULL PROMPT:
2025-03-06 18:58:20,016 - INFO - ----------------------------------------
2025-03-06 18:58:20,016 - INFO - [system]
2025-03-06 18:58:20,016 - INFO - You are a specialized AI for research, providing relevant info for educational content creation. Format your response to be directly usable in educational materials about AI technologies and software development practices. Include specific examples, code samples when relevant, and cite recent sources.
2025-03-06 18:58:20,016 - INFO - ----------------------------------------
2025-03-06 18:58:20,016 - INFO - [user]
2025-03-06 18:58:20,016 - INFO - I'm researching for a use case titled 'Craft Effective Code Prompts for AI Assistance' in the category 'Core Skills'. The objective is: 'Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation'. This is for creating developer educational content about AI skills. In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?
2025-03-06 18:58:20,016 - INFO - ----------------------------------------
2025-03-06 18:58:20,016 - INFO - ================================================================================

2025-03-06 18:58:40,798 - INFO - HTTP Request: POST https://api.perplexity.ai/chat/completions "HTTP/1.1 200 OK"
2025-03-06 18:58:41,454 - INFO - HTTP Request: POST https://api.perplexity.ai/chat/completions "HTTP/1.1 200 OK"
2025-03-06 18:58:42,656 - INFO - HTTP Request: POST https://api.perplexity.ai/chat/completions "HTTP/1.1 200 OK"
2025-03-06 18:58:46,563 - INFO - 
================================================================================
2025-03-06 18:58:46,564 - INFO - STEP: 2 - Deep Research (Parallel)
2025-03-06 18:58:46,564 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:46,565 - INFO - PROMPT:
2025-03-06 18:58:46,565 - INFO - ----------------------------------------
2025-03-06 18:58:46,565 - INFO - How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?
What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?
In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?
2025-03-06 18:58:46,565 - INFO - ----------------------------------------
2025-03-06 18:58:46,565 - INFO - RESPONSE:
2025-03-06 18:58:46,565 - INFO - ----------------------------------------
2025-03-06 18:58:46,565 - INFO - {
  "content": "Q: How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?\nA: To craft effective code prompts for AI assistance, particularly for Python development using GitHub Copilot with GPT-4, developers should focus on optimizing their docstrings and TODO comments. This approach can significantly enhance communication of complex algorithmic intents and improve the accuracy of AI-generated code. Here's a comprehensive guide on how to achieve this, along with potential pitfalls to be aware of:\n\n## Optimizing Python Docstrings for AI Prompts\n\n### Clear and Concise Function Descriptions\n\nStart your docstrings with a clear, concise description of the function's purpose. This helps the AI understand the overall intent quickly.\n\n```python\ndef calculate_fibonacci(n):\n    \"\"\"\n    Calculate the nth Fibonacci number using dynamic programming.\n    \"\"\"\n    # Implementation here\n```\n\n### Detailed Parameter Descriptions\n\nProvide detailed descriptions for each parameter, including type hints and expected value ranges.\n\n```python\ndef process_data(data: List[Dict], threshold: float = 0.5):\n    \"\"\"\n    Process a list of data dictionaries based on a threshold value.\n\n    :param data: List of dictionaries containing data points\n    :param threshold: Float value between 0 and 1 for filtering (default: 0.5)\n    :return: Processed data as a new list of dictionaries\n    \"\"\"\n    # Implementation here\n```\n\n### Expected Return Values\n\nClearly state the expected return value(s) and their format.\n\n```python\ndef analyze_text(text: str) -> Dict[str, Any]:\n    \"\"\"\n    Analyze the given text and return various metrics.\n\n    :param text: Input text to analyze\n    :return: Dictionary containing:\n             - 'word_count': int, number of words\n             - 'sentiment': float, sentiment score between -1 and 1\n             - 'key_phrases': List[str], important phrases extracted\n    \"\"\"\n    # Implementation here\n```\n\n### Usage Examples\n\nInclude usage examples in the docstring to demonstrate how the function should be called and what to expect.\n\n```python\ndef create_user(username: str, email: str, age: int) -> Dict[str, Any]:\n    \"\"\"\n    Create a new user with the given details.\n\n    :param username: Unique username for the new user\n    :param email: Valid email address\n    :param age: User's age (must be 18 or older)\n    :return: Dictionary containing user details and generated user ID\n\n    Example:\n    >>> user = create_user(\"john_doe\", \"john@example.com\", 25)\n    >>> print(user)\n    {'id': 'usr_123', 'username': 'john_doe', 'email': 'john@example.com', 'age': 25}\n    \"\"\"\n    # Implementation here\n```\n\n## Optimizing TODO Comments for AI Prompts\n\n### Specific Action Items\n\nMake TODO comments specific about what needs to be done, providing clear direction for the AI.\n\n```python\n# TODO: Implement caching mechanism for API responses to reduce network calls\n```\n\n### Context and Constraints\n\nInclude relevant context and any constraints in the TODO comment to guide the AI's code generation.\n\n```python\n# TODO: Optimize the sorting algorithm for large datasets (>1M elements)\n# Consider using a hybrid approach combining quicksort and insertion sort\n```\n\n### Expected Behavior\n\nDescribe the expected behavior or output of the code to be implemented.\n\n```python\n# TODO: Add input validation for the 'process_data' function\n# Ensure that 'data' is a non-empty list and 'threshold' is between 0 and 1\n```\n\n### References to Relevant Documentation or Standards\n\nInclude references to documentation or standards that the implementation should adhere to.\n\n```python\n# TODO: Implement OAuth2 authentication flow as per RFC 6749\n# Refer to: https://tools.ietf.org/html/rfc6749\n```\n\n## Pitfalls to Be Aware Of\n\n1. **Overreliance on AI**: Don't rely solely on AI-generated code. Always review and test the output[4].\n\n2. **Security Vulnerabilities**: AI may inadvertently introduce security vulnerabilities. Thoroughly review generated code for potential security issues[4].\n\n3. **Code Quality Concerns**: AI-generated code may not always adhere to best practices or project-specific standards. Ensure the code meets your quality requirements[4].\n\n4. **Incomplete Context**: Providing insufficient context in prompts can lead to inaccurate or irrelevant code generation[1].\n\n5. **Intellectual Property Issues**: Be cautious about using copyrighted code or algorithms in your prompts, as this may lead to legal issues[3].\n\n6. **Overcomplicating Prompts**: Excessively complex prompts may confuse the AI and result in less accurate code generation[5].\n\n7. **Ignoring Edge Cases**: Ensure your prompts consider edge cases and error handling to generate robust code[2].\n\n8. **Lack of Documentation**: While AI can generate code, it may not always provide adequate inline comments or documentation. Ensure critical parts of the code are well-documented[2].\n\nBy following these guidelines and being aware of the potential pitfalls, developers can effectively communicate their programming intent through structured comments and docstrings, leading to more accurate and useful AI-generated code. Remember that while AI tools like GitHub Copilot can significantly enhance productivity, they should be used as assistants rather than replacements for human expertise and judgment in software development.\n\nQ: What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?\nA: To craft effective code prompts for AI assistance, developers should follow several best practices to maximize the accuracy of AI-generated code and ensure it aligns with their original intent. Here's a comprehensive guide on structuring prompts and validating the results:\n\n## Structuring Effective Code Prompts\n\n### Be Specific and Contextual\n\nProvide clear, detailed instructions about what you want the AI to generate. Include information about:\n\n- Programming language\n- Framework or libraries being used\n- Desired functionality\n- Input/output expectations\n- Any constraints or edge cases to consider\n\nExample:\n```\nGenerate a Python function using the requests library to fetch data from a REST API. The function should handle pagination, rate limiting, and error responses. It should return the data as a list of dictionaries.\n```\n\n### Use a Consistent Format\n\nAdopt a consistent structure for your prompts to help the AI understand your requirements better. A common format is:\n\n1. Task description\n2. Input parameters\n3. Expected output\n4. Additional constraints or requirements\n\nExample:\n```\nTask: Create a sorting algorithm\nInput: An unsorted list of integers\nOutput: A sorted list in ascending order\nConstraints: \n- Use the quicksort algorithm\n- Optimize for space complexity\n- Include comments explaining the logic\n```\n\n### Provide Examples\n\nWhen possible, include sample inputs and expected outputs to guide the AI's understanding:\n\n```\nCreate a function that calculates the Fibonacci sequence. \nExample input: n = 5\nExpected output: [0, 1, 1, 2, 3]\n```\n\n### Specify the Coding Style\n\nMention any specific coding style or conventions you want the AI to follow:\n\n```\nWrite a Java class following the JavaBeans convention. Use camelCase for method names and include appropriate getter and setter methods.\n```\n\n### Request Explanations\n\nAsk the AI to include comments or explanations for complex logic:\n\n```\nImplement a binary search tree in C++. Include comments explaining the logic behind insertion, deletion, and traversal operations.\n```\n\n## Validating AI-Generated Code\n\nTo ensure the AI-generated code matches the original developer intent, consider these validation techniques:\n\n### Code Review\n\nCarefully review the generated code to ensure it meets your requirements. Look for:\n\n- Correct implementation of the requested functionality\n- Proper handling of edge cases\n- Adherence to specified coding style and conventions\n\n### Test Case Generation\n\nAsk the AI to generate test cases along with the code:\n\n```\nCreate a function to validate email addresses in JavaScript. Also, provide a set of test cases covering various scenarios, including valid and invalid email formats.\n```\n\n### Iterative Refinement\n\nIf the initial output doesn't fully meet your needs, iterate on your prompt:\n\n1. Identify specific areas that need improvement\n2. Provide feedback to the AI\n3. Ask for modifications or enhancements\n\nExample:\n```\nThe previous implementation was good, but it didn't handle the case of empty input. Please modify the function to return an appropriate error message for empty or null inputs.\n```\n\n### Live Programming Validation\n\nUtilize live programming environments to immediately test and validate the generated code:\n\n1. Set up a live coding environment (e.g., Jupyter Notebooks for Python)\n2. Paste the AI-generated code into the environment\n3. Execute the code with various inputs\n4. Observe the outputs and behavior in real-time\n\nThis approach allows for quick iteration and refinement of both the prompt and the generated code.\n\n### Static Analysis\n\nRun static analysis tools on the generated code to check for:\n\n- Potential bugs or security vulnerabilities\n- Adherence to coding standards\n- Performance optimizations\n\n### Peer Review\n\nHave other team members review the AI-generated code and the original prompt to ensure it meets team standards and project requirements.\n\n## Best Practices for Inline Chat Prompts\n\nWhen using inline chat for code generation, consider these additional tips:\n\n1. **Start with a clear objective**: Begin your prompt with a concise statement of what you're trying to achieve.\n\n2. **Use code blocks**: Enclose existing code or expected output in code blocks for clarity.\n\n3. **Break down complex tasks**: For larger features, break them into smaller, manageable prompts.\n\n4. **Reference existing code**: Point the AI to relevant parts of your codebase for context.\n\n5. **Specify error handling**: Explicitly request error handling and edge case management.\n\n6. **Ask for documentation**: Request inline comments or separate documentation for complex logic.\n\n7. **Iterate gradually**: Start with a basic implementation and progressively add complexity through follow-up prompts.\n\nBy following these practices, developers can craft more effective prompts for AI code generation, leading to more accurate and useful outputs that align closely with their original intent. Remember that AI assistance is a tool to enhance productivity, but it's crucial to maintain a critical eye and validate all generated code thoroughly before integration into production systems.\n\nQ: In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?\nA: To effectively craft code prompts for AI assistance and evaluate the outputs, front-end developers can employ several strategies when using GitHub Copilot. Here's a comprehensive approach to structuring comments, iteratively refining outputs, and measuring alignment with requirements:\n\n## Structuring Effective Code Prompts\n\n### Use Clear and Specific Language\n\nWrite comments that clearly state the desired functionality, input/output expectations, and any specific requirements[1]. For example:\n\n```javascript\n// Create a React component that renders a responsive image gallery\n// - Accept an array of image URLs as a prop\n// - Display images in a grid layout (3 columns on desktop, 2 on tablet, 1 on mobile)\n// - Implement lazy loading for performance\n// - Add click functionality to open images in a lightbox\n```\n\n### Provide Context and Constraints\n\nInclude relevant information about the project structure, dependencies, or coding standards[1]. For instance:\n\n```javascript\n// Using React 18 and Tailwind CSS\n// Follow functional component patterns and use hooks\n// Ensure accessibility (WCAG 2.1 AA compliance)\n```\n\n### Break Down Complex Tasks\n\nFor more intricate features, break them into smaller, manageable subtasks[3]. This helps Copilot generate more accurate and focused code:\n\n```javascript\n// Step 1: Create a basic grid layout component\n// Step 2: Implement responsive design using CSS Grid or Flexbox\n// Step 3: Add lazy loading functionality\n// Step 4: Implement lightbox feature\n```\n\n## Iterative Refinement Process\n\n### 1. Initial Generation\n\nStart with a high-level prompt and let Copilot generate an initial implementation[1].\n\n### 2. Review and Analyze\n\nCarefully examine the generated code, identifying areas that need improvement or don't meet the specified requirements[5].\n\n### 3. Targeted Refinement\n\nUse more specific prompts to address identified issues or add missing functionality[1]. For example:\n\n```javascript\n// Refine the lazy loading implementation to use Intersection Observer API\n// Ensure images have appropriate alt text for accessibility\n```\n\n### 4. Collaborative Improvement\n\nLeverage Copilot Chat to ask questions about the generated code, request explanations, or suggest improvements[9]. For instance:\n\n```\n@copilot How can we optimize the image loading performance further?\n```\n\n### 5. Manual Adjustments\n\nMake necessary manual edits to fine-tune the code, ensuring it aligns perfectly with your project's needs and coding standards[5].\n\n## Evaluation Criteria\n\nTo ensure the generated code meets specified requirements, consider the following measurable criteria:\n\n1. **Functionality Completeness**: Does the code implement all requested features?[5]\n\n2. **Code Quality**: Evaluate metrics such as cyclomatic complexity, maintainability index, and adherence to best practices[7].\n\n3. **Performance**: Measure load times, rendering performance, and resource usage[7].\n\n4. **Accessibility**: Use automated tools to check WCAG compliance levels[9].\n\n5. **Responsiveness**: Test across various device sizes to ensure proper layout adaptation[1].\n\n6. **Browser Compatibility**: Verify functionality across target browsers.\n\n7. **Error Handling**: Assess how well the code handles edge cases and potential errors[5].\n\n8. **Code Consistency**: Ensure the generated code follows project-specific coding standards and patterns[1].\n\n9. **Documentation Quality**: Evaluate the clarity and completeness of inline comments and any generated documentation[2].\n\n10. **Test Coverage**: If tests are generated, measure the percentage of code covered by unit tests[7].\n\n## Measurement Techniques\n\n1. **Automated Testing**: Implement unit tests, integration tests, and end-to-end tests to verify functionality and catch regressions[7].\n\n2. **Code Review Checklists**: Create a standardized checklist based on your evaluation criteria for consistent review processes[5].\n\n3. **Performance Profiling**: Use browser developer tools and specialized profiling software to measure rendering times, memory usage, and other performance metrics[7].\n\n4. **Accessibility Audits**: Employ tools like axe-core or Lighthouse to conduct automated accessibility checks[9].\n\n5. **User Testing**: Gather feedback from real users to assess the usability and effectiveness of the implemented features.\n\n6. **Static Code Analysis**: Utilize tools like ESLint, SonarQube, or GitHub's CodeQL to identify potential issues and measure code quality metrics[7].\n\n7. **Cross-browser Testing**: Use services like BrowserStack or Sauce Labs to verify compatibility across different browsers and devices.\n\n8. **Peer Reviews**: Engage other developers in reviewing the generated code to catch issues that automated tools might miss[5].\n\nBy following this structured approach to crafting prompts, iteratively refining outputs, and rigorously evaluating the results, front-end developers can effectively leverage GitHub Copilot to generate high-quality, requirement-aligned code. This process not only improves the accuracy of AI-generated code but also enhances the developer's skills in working with AI coding assistants, a crucial competency in modern software development.\n",
  "citations": [
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://dr.lib.iastate.edu/server/api/core/bitstreams/7ba5079d-b83c-4d10-bf6c-344df48bda75/content",
      "title": null,
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Learn | Sonar",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - Prompting - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.jetbrains.com/help/pycharm/using-todo.html",
      "title": "TODO comments | PyCharm Documentation",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.jetbrains.com/help/idea/using-todo.html",
      "title": "TODO comments | IntelliJ\u00a0IDEA Documentation",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.revelo.com/blog/ai-generated-code",
      "title": "Understanding the Risks & Benefits of AI Code",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.ninjatech.ai/blog/using-ninjas-ai-code-generator-to-comment-your-code",
      "title": "Adding Comments with an AI Code Generator | Ninja AI",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - Prompting - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation/",
      "title": "What is AI Code Generation? Benefits, Tools & Challenges   | Sonar",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://adamfard.com/blog/how-to-use-chatgpt-4",
      "title": "How to Use ChatGPT-4: A Comprehensive Guide",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://workik.com/code-comment-generator",
      "title": "FREE AI Code Comment Generator - Enhance Code Clarity",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
      "title": "Best practices for using GitHub Copilot - GitHub Docs",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://www.ninjatech.ai/blog/using-ninjas-ai-code-generator-to-comment-your-code",
      "title": "Adding Comments with an AI Code Generator | Ninja AI",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://devblogs.microsoft.com/ise/code-generation-evaluation/",
      "title": null,
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - Prompting - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/",
      "title": "How to write better prompts for GitHub Copilot - The GitHub Blog",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://linearb.io/blog/AI-metrics-how-to-measure-gen-ai-code",
      "title": "AI Metrics: How to Measure Gen AI Code | LinearB Blog",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://adamfard.com/blog/how-to-use-chatgpt-4",
      "title": "How to Use ChatGPT-4: A Comprehensive Guide",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
      "title": "Prompt engineering for Copilot Chat - GitHub Docs",
      "snippet": null,
      "relevance_score": null
    },
    {
      "url": "https://workik.com/code-comment-generator",
      "title": "FREE AI Code Comment Generator - Enhance Code Clarity",
      "snippet": null,
      "relevance_score": null
    }
  ]
}
2025-03-06 18:58:46,569 - INFO - ================================================================================

2025-03-06 18:58:46,570 - INFO - 
Completed step 2: Deep research phase
2025-03-06 18:58:46,570 - INFO - 
================================================================================
2025-03-06 18:58:46,570 - INFO - INITIATING STEP: 3 - Citation Scoring
2025-03-06 18:58:46,570 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:46,570 - INFO - FULL PROMPT:
2025-03-06 18:58:46,570 - INFO - ----------------------------------------
2025-03-06 18:58:46,570 - INFO - [system]
2025-03-06 18:58:46,570 - INFO - You will be given a list of citations from research. Score each citation's relevance to our use case (0.0 to 1.0) and classify them into two categories.

Context:
- Tool: GitHub Copilot
- Language: Python
- Mode: inline chat

1. Official Resources (score >= 0.9):
   - Official documentation from the tool/language vendor
   - Official blogs or tutorials from the tool/language creator
   - Official GitHub repositories or documentation
   Priority order:
   a) Tool-specific documentation (e.g. GitHub Copilot docs)
   b) Language-specific documentation (e.g. Python docs)
   c) Mode-specific documentation (e.g. inline chat docs)
2. Other Resources (score based on):
   - Recency of the source
   - Authority of the source
   - Direct relevance to our specific use case
   - Practical value for developers

Return a JSON object with two arrays:
1. 'official_resources': Array of 2-4 best official documentation URLs, each containing:
   - url: The documentation URL
   - title: Clear title describing the resource
   - type: One of ['tool', 'language', 'mode']
   - section: Specific section of docs if applicable
2. 'citations': Array of other relevant citations with scores >= 0.7
Each citation should include url, title, and relevance_score fields.
2025-03-06 18:58:46,571 - INFO - ----------------------------------------
2025-03-06 18:58:46,571 - INFO - [user]
2025-03-06 18:58:46,571 - INFO - Score these citations for the use case:

<Use_Case_ID>CORE-02</Use_Case_ID>
<Use_Case>Craft Effective Code Prompts for AI Assistance</Use_Case>
<Family>Core Skills</Family>
<AI_Tool>Coding Assistants</AI_Tool>
<Objective>Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation</Objective>
<Description>This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.</Description>
<Prerequisites>
- Writing clear code comments
- Understanding code structure
- Basic algorithmic thinking
- Familiarity with code completion tools
- Basic understanding of natural language processing
</Prerequisites>
<Time_Estimate>20 minutes</Time_Estimate>
<Steps>
- Write a detailed function description in docstring format
- Add TODO comments with specific algorithm requirements
- Use natural language to describe complex logic before implementation
- Refine prompts based on initial AI outputs
- Validate generated code against original intent
</Steps>
<Tool>GitHub Copilot</Tool>
<Department>SWE</Department>
<Role>front-end</Role>
<Mode>inline chat</Mode>
<Model>GPT-4o</Model>
<Coding_Language>Python</Coding_Language>


Citations:
[
  {
    "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
    "title": "AI Prompting Best Practices | Codecademy",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
    "title": "Comments and Documentation in Python | CodeSignal Learn",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://dr.lib.iastate.edu/server/api/core/bitstreams/7ba5079d-b83c-4d10-bf6c-344df48bda75/content",
    "title": null,
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
    "title": "AI Code Generation Benefits & Risks | Learn | Sonar",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
    "title": "A Guide to Crafting Effective Prompts for Diverse Applications - Prompting - OpenAI Developer Community",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.huit.harvard.edu/news/ai-prompts",
    "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.jetbrains.com/help/pycharm/using-todo.html",
    "title": "TODO comments | PyCharm Documentation",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.jetbrains.com/help/idea/using-todo.html",
    "title": "TODO comments | IntelliJ\u00a0IDEA Documentation",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.revelo.com/blog/ai-generated-code",
    "title": "Understanding the Risks & Benefits of AI Code",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
    "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
    "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.ninjatech.ai/blog/using-ninjas-ai-code-generator-to-comment-your-code",
    "title": "Adding Comments with an AI Code Generator | Ninja AI",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
    "title": "Validating AI-Generated Code with Live Programming - YouTube",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
    "title": "A Guide to Crafting Effective Prompts for Diverse Applications - Prompting - OpenAI Developer Community",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.huit.harvard.edu/news/ai-prompts",
    "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
    "title": "GenAIScript - Comment Code with AI - DEV Community",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.sonarsource.com/learn/ai-code-generation/",
    "title": "What is AI Code Generation? Benefits, Tools & Challenges   | Sonar",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://adamfard.com/blog/how-to-use-chatgpt-4",
    "title": "How to Use ChatGPT-4: A Comprehensive Guide",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
    "title": "How to write better AI prompts - LeadDev",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://workik.com/code-comment-generator",
    "title": "FREE AI Code Comment Generator - Enhance Code Clarity",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
    "title": "Best practices for using GitHub Copilot - GitHub Docs",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://www.ninjatech.ai/blog/using-ninjas-ai-code-generator-to-comment-your-code",
    "title": "Adding Comments with an AI Code Generator | Ninja AI",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://devblogs.microsoft.com/ise/code-generation-evaluation/",
    "title": null,
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
    "title": "A Guide to Crafting Effective Prompts for Diverse Applications - Prompting - OpenAI Developer Community",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/",
    "title": "How to write better prompts for GitHub Copilot - The GitHub Blog",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
    "title": "GenAIScript - Comment Code with AI - DEV Community",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://linearb.io/blog/AI-metrics-how-to-measure-gen-ai-code",
    "title": "AI Metrics: How to Measure Gen AI Code | LinearB Blog",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://adamfard.com/blog/how-to-use-chatgpt-4",
    "title": "How to Use ChatGPT-4: A Comprehensive Guide",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
    "title": "Prompt engineering for Copilot Chat - GitHub Docs",
    "snippet": null,
    "relevance_score": null
  },
  {
    "url": "https://workik.com/code-comment-generator",
    "title": "FREE AI Code Comment Generator - Enhance Code Clarity",
    "snippet": null,
    "relevance_score": null
  }
]
2025-03-06 18:58:46,571 - INFO - ----------------------------------------
2025-03-06 18:58:46,571 - INFO - ================================================================================

2025-03-06 18:58:54,725 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-03-06 18:58:54,728 - INFO - 
================================================================================
2025-03-06 18:58:54,728 - INFO - INITIATING STEP: 3 - Refine Use Case
2025-03-06 18:58:54,728 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:58:54,729 - INFO - FULL PROMPT:
2025-03-06 18:58:54,729 - INFO - ----------------------------------------
2025-03-06 18:58:54,729 - INFO - [system]
2025-03-06 18:58:54,729 - INFO - You are an AI assistant tasked with creating a comprehensive, structured use case by merging research findings with the original use case design. The output must be valid JSON following the 'UseCaseStructuredOutput' schema.

CRITICAL INTEGRATION REQUIREMENTS:

1. TECHNICAL ACCURACY:
   - Preserve all specific tool versions, models, and technical details from the original config
   - Maintain accuracy of any programming languages, frameworks, or platforms specified
   - Ensure all technical prerequisites and dependencies are correctly represented

2. CONFIGURATION FIDELITY:
   - Retain and emphasize the specific AI tools and models mentioned (e.g., exact versions, capabilities)
   - Preserve the intended complexity level and time estimates
   - Maintain alignment with specified roles and departments
   - Honor any mode-specific requirements (e.g., agentic, interactive)

3. RESEARCH INTEGRATION:
   - Incorporate relevant research findings while preserving config-specified constraints
   - Validate that research aligns with specified tools and versions
   - Ensure best practices are compatible with the configured environment

4. CONTENT STRUCTURE:
   - Each step must directly relate to the configured tools and environment
   - Examples and code snippets must match specified language and tool versions
   - Maintain traceability between steps and original requirements

ADDITIONAL POLISH REQUIREMENTS:
- Keep the example solution step intact and aligned with config specifications
- Ensure steps are bullet-listed, time-bound, and guideline-compliant
- Maintain conversational tone while preserving technical accuracy
- Address the reader as 'you' while maintaining professional tone
- Focus on tool-specific usage rather than fundamental concepts
- Preserve all critical metadata from the original configuration

OUTPUT REQUIREMENTS:
- Must be valid JSON matching UseCaseStructuredOutput schema
- All technical details must be accurate and config-aligned
- Content must be immediately actionable and environment-ready


• Content is written at an 8th-grade reading level: Content is easy for anyone to understand.
• Content is written in the active voice: Writing empowers learners to find solutions and take action. Passive voice is avoided.
• Content addresses the reader as "you": Point of view is consistent and avoids third-person references like "business leaders" or "apprentices."
• Content is written in a conversational tone: The tone is action-oriented, clear, and energized. Content should assume the knowledge of an average junior developer and minimize the use of unnecessary jargon. Define any terms or processes that are more complex or advanced.
• Content is in US English: Content follows US spelling, grammar, and punctuation unless written explicitly for a UK-based audience.
• Content is concise: Writing is focused and to-the-point.
• Content is broken into digestible sections. Text that is longer than a sentence is broken down into bullets.
• Bullets, headings, and formatting help scanning: Formatting makes content easy to navigate and understand.
• Content is free of spelling, grammar, and punctuation errors: Writing adheres to professional standards.
• Grammar and punctuation follow the Chicago Manual of Style: There is consistency across all content.
• Sentence case is used for all titles and headings: Titles and headings are formatted with minimal capitalization.
• Numbers, dates, times, percentages, and money are consistently formatted: Words are used for numbers zero through nine, numerals for 10 and above, dates follow "Month Day, Year," times are formatted like "10:30am," percentages use %, and money uses currency symbols.
• All original sources are cited using Chicago style: Whenever data is referenced, the original source is cited and linked.
• Writing is bias-free: Content depicts diverse perspectives, avoids stereotypes, and uses gender-neutral terms. Militaristic, exclusionary language is not used. (eg: "sale representative" vs "salesman")
• Writing avoids outdated or inappropriate acronyms: Precise terms are used when referring to specific groups. ("Permit list" vs "Whitelist")
• Writing uses asset-based, specific language: Writing focuses on strengths and potential rather than deficits. (eg: "learners with additional learning needs" vs "special needs learners")


Use Case Guidelines:
1. Structure and Format:
   - Follow the provided XML structure consistently
   - Include all required sections: Overview, Description, Objective, Prerequisites, Steps, Metrics
   - Ensure each section has a clear purpose and adds value

2. Content Quality Standards:
   - Clear, specific, time-bound, relevant, achievable goals
   - Repeatable, measurable processes and outcomes
   - Each step must be essential and purposeful
   - Steps should be sequential, logical, and self-contained

3. Technical Aspects:
   - Include accurate time estimates for completion
   - Clearly define all prerequisites and dependencies
   - Specify required tools, permissions, and resources
   - Document potential obstacles and mitigation strategies

4. Implementation Guidance:
   - Provide concrete, actionable examples where appropriate
   - Include verification steps to confirm successful completion
   - Define measurable success criteria and metrics
   - Address common variations and edge cases

5. Integration:
   - Reference related use cases when appropriate
   - Ensure consistency with other documentation
   - Identify where this use case fits in larger workflows

2025-03-06 18:58:54,729 - INFO - ----------------------------------------
2025-03-06 18:58:54,730 - INFO - [assistant]
2025-03-06 18:58:54,730 - INFO - Research Findings:
Q: How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?
A: To craft effective code prompts for AI assistance, particularly for Python development using GitHub Copilot with GPT-4, developers should focus on optimizing their docstrings and TODO comments. This approach can significantly enhance communication of complex algorithmic intents and improve the accuracy of AI-generated code. Here's a comprehensive guide on how to achieve this, along with potential pitfalls to be aware of:

## Optimizing Python Docstrings for AI Prompts

### Clear and Concise Function Descriptions

Start your docstrings with a clear, concise description of the function's purpose. This helps the AI understand the overall intent quickly.

```python
def calculate_fibonacci(n):
    """
    Calculate the nth Fibonacci number using dynamic programming.
    """
    # Implementation here
```

### Detailed Parameter Descriptions

Provide detailed descriptions for each parameter, including type hints and expected value ranges.

```python
def process_data(data: List[Dict], threshold: float = 0.5):
    """
    Process a list of data dictionaries based on a threshold value.

    :param data: List of dictionaries containing data points
    :param threshold: Float value between 0 and 1 for filtering (default: 0.5)
    :return: Processed data as a new list of dictionaries
    """
    # Implementation here
```

### Expected Return Values

Clearly state the expected return value(s) and their format.

```python
def analyze_text(text: str) -> Dict[str, Any]:
    """
    Analyze the given text and return various metrics.

    :param text: Input text to analyze
    :return: Dictionary containing:
             - 'word_count': int, number of words
             - 'sentiment': float, sentiment score between -1 and 1
             - 'key_phrases': List[str], important phrases extracted
    """
    # Implementation here
```

### Usage Examples

Include usage examples in the docstring to demonstrate how the function should be called and what to expect.

```python
def create_user(username: str, email: str, age: int) -> Dict[str, Any]:
    """
    Create a new user with the given details.

    :param username: Unique username for the new user
    :param email: Valid email address
    :param age: User's age (must be 18 or older)
    :return: Dictionary containing user details and generated user ID

    Example:
    >>> user = create_user("john_doe", "john@example.com", 25)
    >>> print(user)
    {'id': 'usr_123', 'username': 'john_doe', 'email': 'john@example.com', 'age': 25}
    """
    # Implementation here
```

## Optimizing TODO Comments for AI Prompts

### Specific Action Items

Make TODO comments specific about what needs to be done, providing clear direction for the AI.

```python
# TODO: Implement caching mechanism for API responses to reduce network calls
```

### Context and Constraints

Include relevant context and any constraints in the TODO comment to guide the AI's code generation.

```python
# TODO: Optimize the sorting algorithm for large datasets (>1M elements)
# Consider using a hybrid approach combining quicksort and insertion sort
```

### Expected Behavior

Describe the expected behavior or output of the code to be implemented.

```python
# TODO: Add input validation for the 'process_data' function
# Ensure that 'data' is a non-empty list and 'threshold' is between 0 and 1
```

### References to Relevant Documentation or Standards

Include references to documentation or standards that the implementation should adhere to.

```python
# TODO: Implement OAuth2 authentication flow as per RFC 6749
# Refer to: https://tools.ietf.org/html/rfc6749
```

## Pitfalls to Be Aware Of

1. **Overreliance on AI**: Don't rely solely on AI-generated code. Always review and test the output[4].

2. **Security Vulnerabilities**: AI may inadvertently introduce security vulnerabilities. Thoroughly review generated code for potential security issues[4].

3. **Code Quality Concerns**: AI-generated code may not always adhere to best practices or project-specific standards. Ensure the code meets your quality requirements[4].

4. **Incomplete Context**: Providing insufficient context in prompts can lead to inaccurate or irrelevant code generation[1].

5. **Intellectual Property Issues**: Be cautious about using copyrighted code or algorithms in your prompts, as this may lead to legal issues[3].

6. **Overcomplicating Prompts**: Excessively complex prompts may confuse the AI and result in less accurate code generation[5].

7. **Ignoring Edge Cases**: Ensure your prompts consider edge cases and error handling to generate robust code[2].

8. **Lack of Documentation**: While AI can generate code, it may not always provide adequate inline comments or documentation. Ensure critical parts of the code are well-documented[2].

By following these guidelines and being aware of the potential pitfalls, developers can effectively communicate their programming intent through structured comments and docstrings, leading to more accurate and useful AI-generated code. Remember that while AI tools like GitHub Copilot can significantly enhance productivity, they should be used as assistants rather than replacements for human expertise and judgment in software development.

Q: What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?
A: To craft effective code prompts for AI assistance, developers should follow several best practices to maximize the accuracy of AI-generated code and ensure it aligns with their original intent. Here's a comprehensive guide on structuring prompts and validating the results:

## Structuring Effective Code Prompts

### Be Specific and Contextual

Provide clear, detailed instructions about what you want the AI to generate. Include information about:

- Programming language
- Framework or libraries being used
- Desired functionality
- Input/output expectations
- Any constraints or edge cases to consider

Example:
```
Generate a Python function using the requests library to fetch data from a REST API. The function should handle pagination, rate limiting, and error responses. It should return the data as a list of dictionaries.
```

### Use a Consistent Format

Adopt a consistent structure for your prompts to help the AI understand your requirements better. A common format is:

1. Task description
2. Input parameters
3. Expected output
4. Additional constraints or requirements

Example:
```
Task: Create a sorting algorithm
Input: An unsorted list of integers
Output: A sorted list in ascending order
Constraints: 
- Use the quicksort algorithm
- Optimize for space complexity
- Include comments explaining the logic
```

### Provide Examples

When possible, include sample inputs and expected outputs to guide the AI's understanding:

```
Create a function that calculates the Fibonacci sequence. 
Example input: n = 5
Expected output: [0, 1, 1, 2, 3]
```

### Specify the Coding Style

Mention any specific coding style or conventions you want the AI to follow:

```
Write a Java class following the JavaBeans convention. Use camelCase for method names and include appropriate getter and setter methods.
```

### Request Explanations

Ask the AI to include comments or explanations for complex logic:

```
Implement a binary search tree in C++. Include comments explaining the logic behind insertion, deletion, and traversal operations.
```

## Validating AI-Generated Code

To ensure the AI-generated code matches the original developer intent, consider these validation techniques:

### Code Review

Carefully review the generated code to ensure it meets your requirements. Look for:

- Correct implementation of the requested functionality
- Proper handling of edge cases
- Adherence to specified coding style and conventions

### Test Case Generation

Ask the AI to generate test cases along with the code:

```
Create a function to validate email addresses in JavaScript. Also, provide a set of test cases covering various scenarios, including valid and invalid email formats.
```

### Iterative Refinement

If the initial output doesn't fully meet your needs, iterate on your prompt:

1. Identify specific areas that need improvement
2. Provide feedback to the AI
3. Ask for modifications or enhancements

Example:
```
The previous implementation was good, but it didn't handle the case of empty input. Please modify the function to return an appropriate error message for empty or null inputs.
```

### Live Programming Validation

Utilize live programming environments to immediately test and validate the generated code:

1. Set up a live coding environment (e.g., Jupyter Notebooks for Python)
2. Paste the AI-generated code into the environment
3. Execute the code with various inputs
4. Observe the outputs and behavior in real-time

This approach allows for quick iteration and refinement of both the prompt and the generated code.

### Static Analysis

Run static analysis tools on the generated code to check for:

- Potential bugs or security vulnerabilities
- Adherence to coding standards
- Performance optimizations

### Peer Review

Have other team members review the AI-generated code and the original prompt to ensure it meets team standards and project requirements.

## Best Practices for Inline Chat Prompts

When using inline chat for code generation, consider these additional tips:

1. **Start with a clear objective**: Begin your prompt with a concise statement of what you're trying to achieve.

2. **Use code blocks**: Enclose existing code or expected output in code blocks for clarity.

3. **Break down complex tasks**: For larger features, break them into smaller, manageable prompts.

4. **Reference existing code**: Point the AI to relevant parts of your codebase for context.

5. **Specify error handling**: Explicitly request error handling and edge case management.

6. **Ask for documentation**: Request inline comments or separate documentation for complex logic.

7. **Iterate gradually**: Start with a basic implementation and progressively add complexity through follow-up prompts.

By following these practices, developers can craft more effective prompts for AI code generation, leading to more accurate and useful outputs that align closely with their original intent. Remember that AI assistance is a tool to enhance productivity, but it's crucial to maintain a critical eye and validate all generated code thoroughly before integration into production systems.

Q: In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?
A: To effectively craft code prompts for AI assistance and evaluate the outputs, front-end developers can employ several strategies when using GitHub Copilot. Here's a comprehensive approach to structuring comments, iteratively refining outputs, and measuring alignment with requirements:

## Structuring Effective Code Prompts

### Use Clear and Specific Language

Write comments that clearly state the desired functionality, input/output expectations, and any specific requirements[1]. For example:

```javascript
// Create a React component that renders a responsive image gallery
// - Accept an array of image URLs as a prop
// - Display images in a grid layout (3 columns on desktop, 2 on tablet, 1 on mobile)
// - Implement lazy loading for performance
// - Add click functionality to open images in a lightbox
```

### Provide Context and Constraints

Include relevant information about the project structure, dependencies, or coding standards[1]. For instance:

```javascript
// Using React 18 and Tailwind CSS
// Follow functional component patterns and use hooks
// Ensure accessibility (WCAG 2.1 AA compliance)
```

### Break Down Complex Tasks

For more intricate features, break them into smaller, manageable subtasks[3]. This helps Copilot generate more accurate and focused code:

```javascript
// Step 1: Create a basic grid layout component
// Step 2: Implement responsive design using CSS Grid or Flexbox
// Step 3: Add lazy loading functionality
// Step 4: Implement lightbox feature
```

## Iterative Refinement Process

### 1. Initial Generation

Start with a high-level prompt and let Copilot generate an initial implementation[1].

### 2. Review and Analyze

Carefully examine the generated code, identifying areas that need improvement or don't meet the specified requirements[5].

### 3. Targeted Refinement

Use more specific prompts to address identified issues or add missing functionality[1]. For example:

```javascript
// Refine the lazy loading implementation to use Intersection Observer API
// Ensure images have appropriate alt text for accessibility
```

### 4. Collaborative Improvement

Leverage Copilot Chat to ask questions about the generated code, request explanations, or suggest improvements[9]. For instance:

```
@copilot How can we optimize the image loading performance further?
```

### 5. Manual Adjustments

Make necessary manual edits to fine-tune the code, ensuring it aligns perfectly with your project's needs and coding standards[5].

## Evaluation Criteria

To ensure the generated code meets specified requirements, consider the following measurable criteria:

1. **Functionality Completeness**: Does the code implement all requested features?[5]

2. **Code Quality**: Evaluate metrics such as cyclomatic complexity, maintainability index, and adherence to best practices[7].

3. **Performance**: Measure load times, rendering performance, and resource usage[7].

4. **Accessibility**: Use automated tools to check WCAG compliance levels[9].

5. **Responsiveness**: Test across various device sizes to ensure proper layout adaptation[1].

6. **Browser Compatibility**: Verify functionality across target browsers.

7. **Error Handling**: Assess how well the code handles edge cases and potential errors[5].

8. **Code Consistency**: Ensure the generated code follows project-specific coding standards and patterns[1].

9. **Documentation Quality**: Evaluate the clarity and completeness of inline comments and any generated documentation[2].

10. **Test Coverage**: If tests are generated, measure the percentage of code covered by unit tests[7].

## Measurement Techniques

1. **Automated Testing**: Implement unit tests, integration tests, and end-to-end tests to verify functionality and catch regressions[7].

2. **Code Review Checklists**: Create a standardized checklist based on your evaluation criteria for consistent review processes[5].

3. **Performance Profiling**: Use browser developer tools and specialized profiling software to measure rendering times, memory usage, and other performance metrics[7].

4. **Accessibility Audits**: Employ tools like axe-core or Lighthouse to conduct automated accessibility checks[9].

5. **User Testing**: Gather feedback from real users to assess the usability and effectiveness of the implemented features.

6. **Static Code Analysis**: Utilize tools like ESLint, SonarQube, or GitHub's CodeQL to identify potential issues and measure code quality metrics[7].

7. **Cross-browser Testing**: Use services like BrowserStack or Sauce Labs to verify compatibility across different browsers and devices.

8. **Peer Reviews**: Engage other developers in reviewing the generated code to catch issues that automated tools might miss[5].

By following this structured approach to crafting prompts, iteratively refining outputs, and rigorously evaluating the results, front-end developers can effectively leverage GitHub Copilot to generate high-quality, requirement-aligned code. This process not only improves the accuracy of AI-generated code but also enhances the developer's skills in working with AI coding assistants, a crucial competency in modern software development.


Selected Citations:
[
  {
    "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
    "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
    "relevance_score": 0.9
  },
  {
    "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
    "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
    "relevance_score": 0.9
  },
  {
    "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
    "title": "How to write better AI prompts - LeadDev",
    "relevance_score": 0.85
  },
  {
    "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
    "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
    "relevance_score": 0.85
  },
  {
    "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
    "title": "AI Prompting Best Practices | Codecademy",
    "relevance_score": 0.8
  },
  {
    "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
    "title": "Comments and Documentation in Python | CodeSignal Learn",
    "relevance_score": 0.75
  },
  {
    "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
    "title": "AI Code Generation Benefits & Risks | Sonar",
    "relevance_score": 0.7
  },
  {
    "url": "https://www.huit.harvard.edu/news/ai-prompts",
    "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
    "relevance_score": 0.8
  },
  {
    "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
    "title": "Validating AI-Generated Code with Live Programming - YouTube",
    "relevance_score": 0.7
  },
  {
    "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
    "title": "GenAIScript - Comment Code with AI - DEV Community",
    "relevance_score": 0.75
  }
]
2025-03-06 18:58:54,731 - INFO - ----------------------------------------
2025-03-06 18:58:54,731 - INFO - [user]
2025-03-06 18:58:54,731 - INFO - Please combine the research findings with this use case design to create an end-to-end, structured use case. The use case must preserve all critical configuration details while incorporating relevant research insights.

Return valid JSON adhering to the Pydantic schema:

UseCaseStructuredOutput:


<Use_Case_ID>CORE-02</Use_Case_ID>
<Use_Case>Craft Effective Code Prompts for AI Assistance</Use_Case>
<Family>Core Skills</Family>
<AI_Tool>Coding Assistants</AI_Tool>
<Objective>Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation</Objective>
<Description>This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.</Description>
<Prerequisites>
- Writing clear code comments
- Understanding code structure
- Basic algorithmic thinking
- Familiarity with code completion tools
- Basic understanding of natural language processing
</Prerequisites>
<Time_Estimate>20 minutes</Time_Estimate>
<Steps>
- Write a detailed function description in docstring format
- Add TODO comments with specific algorithm requirements
- Use natural language to describe complex logic before implementation
- Refine prompts based on initial AI outputs
- Validate generated code against original intent
</Steps>
<Tool>GitHub Copilot</Tool>
<Department>SWE</Department>
<Role>front-end</Role>
<Mode>inline chat</Mode>
<Model>GPT-4o</Model>
<Coding_Language>Python</Coding_Language>

2025-03-06 18:58:54,733 - INFO - ----------------------------------------
2025-03-06 18:58:54,734 - INFO - ================================================================================

2025-03-06 18:59:40,909 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-03-06 18:59:40,930 - INFO - 
================================================================================
2025-03-06 18:59:40,930 - INFO - STEP: 3 - Refine Use Case
2025-03-06 18:59:40,930 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:59:40,930 - INFO - PROMPT:
2025-03-06 18:59:40,930 - INFO - ----------------------------------------
2025-03-06 18:59:40,930 - INFO - Please combine the research findings with this use case design to create an end-to-end, structured use case. The use case must preserve all critical configuration details while incorporating relevant research insights.

Return valid JSON adhering to the Pydantic schema:

UseCaseStructuredOutput:


<Use_Case_ID>CORE-02</Use_Case_ID>
<Use_Case>Craft Effective Code Prompts for AI Assistance</Use_Case>
<Family>Core Skills</Family>
<AI_Tool>Coding Assistants</AI_Tool>
<Objective>Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation</Objective>
<Description>This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.</Description>
<Prerequisites>
- Writing clear code comments
- Understanding code structure
- Basic algorithmic thinking
- Familiarity with code completion tools
- Basic understanding of natural language processing
</Prerequisites>
<Time_Estimate>20 minutes</Time_Estimate>
<Steps>
- Write a detailed function description in docstring format
- Add TODO comments with specific algorithm requirements
- Use natural language to describe complex logic before implementation
- Refine prompts based on initial AI outputs
- Validate generated code against original intent
</Steps>
<Tool>GitHub Copilot</Tool>
<Department>SWE</Department>
<Role>front-end</Role>
<Mode>inline chat</Mode>
<Model>GPT-4o</Model>
<Coding_Language>Python</Coding_Language>

2025-03-06 18:59:40,931 - INFO - ----------------------------------------
2025-03-06 18:59:40,931 - INFO - RESPONSE:
2025-03-06 18:59:40,931 - INFO - ----------------------------------------
2025-03-06 18:59:40,931 - INFO - {
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case trains you to harness AI tooling by writing precise comments and docstrings that function as effective prompts for automated code generation. By following research-backed guidelines, you will learn to craft clear, detailed function descriptions and specific TODO comments that communicate your algorithmic intent. This process emphasizes natural language clarity, iterative prompt refinement, and validation of AI-generated outputs to ensure alignment with your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Make sure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
      "title": "Best practices for using GitHub Copilot",
      "type": "tool",
      "section": "Best Practices"
    },
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
      "title": "Prompt engineering for Copilot Chat",
      "type": "mode",
      "section": "Prompt Engineering"
    },
    {
      "url": "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/",
      "title": "How to write better prompts for GitHub Copilot",
      "type": "tool",
      "section": "Prompt Crafting"
    }
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "relevance_score": 0.75
    }
  ]
}
2025-03-06 18:59:40,931 - INFO - ================================================================================

2025-03-06 18:59:40,932 - INFO - 
Completed step 3: Refinement (structured)
2025-03-06 18:59:40,932 - INFO - 
================================================================================
2025-03-06 18:59:40,932 - INFO - INITIATING STEP: 4 - Final Polish
2025-03-06 18:59:40,932 - INFO - --------------------------------------------------------------------------------
2025-03-06 18:59:40,932 - INFO - FULL PROMPT:
2025-03-06 18:59:40,933 - INFO - ----------------------------------------
2025-03-06 18:59:40,933 - INFO - [system]
2025-03-06 18:59:40,933 - INFO - You are an AI writing assistant focused on improving prose clarity and readability while strictly preserving technical accuracy and meaning. You are given a valid JSON object conforming to the 'UseCaseStructuredOutput' schema.

CRITICAL PRESERVATION REQUIREMENTS:
1. Technical Fidelity:
   - Never alter technical specifications or requirements
   - Preserve all tool names, versions, and capabilities exactly
   - Maintain all configuration details precisely
   - Keep all code snippets and technical steps intact

2. Structural Integrity:
   - Maintain exact step ordering and dependencies
   - Preserve all metadata and configuration values
   - Keep all field names and schema structure unchanged
   - Retain all technical prerequisites and requirements

PROSE IMPROVEMENT FOCUS:
1. Readability Enhancements:
   - Align with 8th-grade reading level
   - Use active voice consistently
   - Break down complex sentences
   - Clarify technical concepts without oversimplifying

2. Style Refinements:
   - Maintain professional but conversational tone
   - Address the reader as 'you'
   - Use consistent terminology throughout
   - Ensure clear transitions between steps

3. Format Polish:
   - Structure content in bullet-list style where appropriate
   - Add time estimates to steps when missing
   - Ensure proper paragraph breaks
   - Maintain consistent formatting

BOUNDARIES OF MODIFICATION:
✓ DO:
  - Improve sentence structure and flow
  - Enhance clarity of explanations
  - Fix grammatical issues
  - Standardize formatting

✗ DO NOT:
  - Change technical requirements or specifications
  - Alter tool names, versions, or capabilities
  - Modify step ordering or dependencies
  - Remove or add technical content

OUTPUT REQUIREMENTS:
- Must return valid JSON matching UseCaseStructuredOutput schema
- All technical details must remain unchanged
- Only prose and formatting improvements allowed


• Content is written at an 8th-grade reading level: Content is easy for anyone to understand.
• Content is written in the active voice: Writing empowers learners to find solutions and take action. Passive voice is avoided.
• Content addresses the reader as "you": Point of view is consistent and avoids third-person references like "business leaders" or "apprentices."
• Content is written in a conversational tone: The tone is action-oriented, clear, and energized. Content should assume the knowledge of an average junior developer and minimize the use of unnecessary jargon. Define any terms or processes that are more complex or advanced.
• Content is in US English: Content follows US spelling, grammar, and punctuation unless written explicitly for a UK-based audience.
• Content is concise: Writing is focused and to-the-point.
• Content is broken into digestible sections. Text that is longer than a sentence is broken down into bullets.
• Bullets, headings, and formatting help scanning: Formatting makes content easy to navigate and understand.
• Content is free of spelling, grammar, and punctuation errors: Writing adheres to professional standards.
• Grammar and punctuation follow the Chicago Manual of Style: There is consistency across all content.
• Sentence case is used for all titles and headings: Titles and headings are formatted with minimal capitalization.
• Numbers, dates, times, percentages, and money are consistently formatted: Words are used for numbers zero through nine, numerals for 10 and above, dates follow "Month Day, Year," times are formatted like "10:30am," percentages use %, and money uses currency symbols.
• All original sources are cited using Chicago style: Whenever data is referenced, the original source is cited and linked.
• Writing is bias-free: Content depicts diverse perspectives, avoids stereotypes, and uses gender-neutral terms. Militaristic, exclusionary language is not used. (eg: "sale representative" vs "salesman")
• Writing avoids outdated or inappropriate acronyms: Precise terms are used when referring to specific groups. ("Permit list" vs "Whitelist")
• Writing uses asset-based, specific language: Writing focuses on strengths and potential rather than deficits. (eg: "learners with additional learning needs" vs "special needs learners")


Use Case Guidelines:
1. Structure and Format:
   - Follow the provided XML structure consistently
   - Include all required sections: Overview, Description, Objective, Prerequisites, Steps, Metrics
   - Ensure each section has a clear purpose and adds value

2. Content Quality Standards:
   - Clear, specific, time-bound, relevant, achievable goals
   - Repeatable, measurable processes and outcomes
   - Each step must be essential and purposeful
   - Steps should be sequential, logical, and self-contained

3. Technical Aspects:
   - Include accurate time estimates for completion
   - Clearly define all prerequisites and dependencies
   - Specify required tools, permissions, and resources
   - Document potential obstacles and mitigation strategies

4. Implementation Guidance:
   - Provide concrete, actionable examples where appropriate
   - Include verification steps to confirm successful completion
   - Define measurable success criteria and metrics
   - Address common variations and edge cases

5. Integration:
   - Reference related use cases when appropriate
   - Ensure consistency with other documentation
   - Identify where this use case fits in larger workflows

2025-03-06 18:59:40,933 - INFO - ----------------------------------------
2025-03-06 18:59:40,933 - INFO - [user]
2025-03-06 18:59:40,933 - INFO - Polish the prose and formatting of this use case while strictly preserving all technical content, meaning, and configuration details. Focus only on improving readability and clarity.

{
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case trains you to harness AI tooling by writing precise comments and docstrings that function as effective prompts for automated code generation. By following research-backed guidelines, you will learn to craft clear, detailed function descriptions and specific TODO comments that communicate your algorithmic intent. This process emphasizes natural language clarity, iterative prompt refinement, and validation of AI-generated outputs to ensure alignment with your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Make sure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
      "title": "Best practices for using GitHub Copilot",
      "type": "tool",
      "section": "Best Practices"
    },
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
      "title": "Prompt engineering for Copilot Chat",
      "type": "mode",
      "section": "Prompt Engineering"
    },
    {
      "url": "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/",
      "title": "How to write better prompts for GitHub Copilot",
      "type": "tool",
      "section": "Prompt Crafting"
    }
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "relevance_score": 0.75
    }
  ]
}
2025-03-06 18:59:40,933 - INFO - ----------------------------------------
2025-03-06 18:59:40,933 - INFO - ================================================================================

2025-03-06 19:00:16,032 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-03-06 19:00:16,039 - INFO - 
================================================================================
2025-03-06 19:00:16,039 - INFO - STEP: 4 - Final Polish
2025-03-06 19:00:16,039 - INFO - --------------------------------------------------------------------------------
2025-03-06 19:00:16,039 - INFO - PROMPT:
2025-03-06 19:00:16,039 - INFO - ----------------------------------------
2025-03-06 19:00:16,039 - INFO - Polish the prose and formatting of this use case while strictly preserving all technical content, meaning, and configuration details. Focus only on improving readability and clarity.

{
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case trains you to harness AI tooling by writing precise comments and docstrings that function as effective prompts for automated code generation. By following research-backed guidelines, you will learn to craft clear, detailed function descriptions and specific TODO comments that communicate your algorithmic intent. This process emphasizes natural language clarity, iterative prompt refinement, and validation of AI-generated outputs to ensure alignment with your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Make sure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
      "title": "Best practices for using GitHub Copilot",
      "type": "tool",
      "section": "Best Practices"
    },
    {
      "url": "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
      "title": "Prompt engineering for Copilot Chat",
      "type": "mode",
      "section": "Prompt Engineering"
    },
    {
      "url": "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/",
      "title": "How to write better prompts for GitHub Copilot",
      "type": "tool",
      "section": "Prompt Crafting"
    }
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "relevance_score": 0.75
    }
  ]
}
2025-03-06 19:00:16,039 - INFO - ----------------------------------------
2025-03-06 19:00:16,040 - INFO - RESPONSE:
2025-03-06 19:00:16,040 - INFO - ----------------------------------------
2025-03-06 19:00:16,040 - INFO - {
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case guides you on how to use AI tools by writing precise comments and docstrings that serve as effective prompts for automated code generation. By following research-backed guidelines, you will learn to create clear, detailed function descriptions and specific TODO comments to express your algorithmic intent. This process highlights the importance of natural language clarity, iterative prompt refinement, and validating AI-generated outputs to ensure they match your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Ensure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
    "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
    "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/"
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "snippet": null,
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": 0.75
    }
  ]
}
2025-03-06 19:00:16,040 - INFO - ================================================================================

2025-03-06 19:00:16,041 - INFO - 
Completed step 4: Final polish (structured)
2025-03-06 19:00:16,041 - INFO - 
================================================================================
2025-03-06 19:00:16,041 - INFO - INITIATING STEP: 5 - Example Solution Generation
2025-03-06 19:00:16,041 - INFO - --------------------------------------------------------------------------------
2025-03-06 19:00:16,041 - INFO - FULL PROMPT:
2025-03-06 19:00:16,041 - INFO - ----------------------------------------
2025-03-06 19:00:16,041 - INFO - [system]
2025-03-06 19:00:16,041 - INFO - You are an expert AI instructor creating a practical example solution for a software development use case.
The solution will be demonstrated in a 2-3 minute video by a subject matter expert.

CRITICAL CONFIGURATION DETAILS:
- ID: CORE-02
- Title: Craft Effective Code Prompts for AI Assistance
- Family: Core Skills
- Tool: GitHub Copilot
- Language: Python
- Role: ['front-end']
- Mode: inline chat
- Model: GPT-4o

SOLUTION REQUIREMENTS:

1. TECHNICAL PRECISION:
   - Use exact tool versions and models specified in config
   - Follow language-specific best practices when specified
   - Maintain compatibility with configured environment
   - Include all necessary setup and prerequisites

2. TIME AND SCOPE MANAGEMENT:
   - Solution must be demonstrable in 2-3 minutes
   - Setup time should be realistic and clearly stated
   - Each step should have clear time expectations
   - Complex steps should be broken down appropriately

3. TOOL AND MODEL SPECIFICITY:
   - Use specified tool and language exclusively
   - Leverage unique features of configured tools/models
   - Include version-specific capabilities and syntax
   - Document any version-dependent behavior

4. VALIDATION AND QUALITY:
   - Include explicit validation steps
   - Address common pitfalls specific to chosen tools
   - Provide error handling appropriate to config
   - Ensure reproducibility in specified environment

5. STEP ALIGNMENT:
   - Each solution step must map directly to these use case steps:
[
  "Write detailed function docstring",
  "Add specific TODO comments",
  "Describe complex logic in natural language",
  "Refine your prompts based on initial output",
  "Validate the generated code"
]
   - Maintain consistent terminology with use case
   - Preserve step ordering and dependencies
   - Include transition guidance between steps

OUTPUT STRUCTURE:
1. Must be valid JSON matching ExampleSolutionOutput schema
2. All steps must include:
   - Clear action description
   - Concrete code or prompt examples
   - Expected outcome
3. Demo script must:
   - Reference specific tools and versions
   - Include setup requirements
   - Highlight key technical details
   - Address common issues

BRAND GUIDELINES:

• Content is written at an 8th-grade reading level: Content is easy for anyone to understand.
• Content is written in the active voice: Writing empowers learners to find solutions and take action. Passive voice is avoided.
• Content addresses the reader as "you": Point of view is consistent and avoids third-person references like "business leaders" or "apprentices."
• Content is written in a conversational tone: The tone is action-oriented, clear, and energized. Content should assume the knowledge of an average junior developer and minimize the use of unnecessary jargon. Define any terms or processes that are more complex or advanced.
• Content is in US English: Content follows US spelling, grammar, and punctuation unless written explicitly for a UK-based audience.
• Content is concise: Writing is focused and to-the-point.
• Content is broken into digestible sections. Text that is longer than a sentence is broken down into bullets.
• Bullets, headings, and formatting help scanning: Formatting makes content easy to navigate and understand.
• Content is free of spelling, grammar, and punctuation errors: Writing adheres to professional standards.
• Grammar and punctuation follow the Chicago Manual of Style: There is consistency across all content.
• Sentence case is used for all titles and headings: Titles and headings are formatted with minimal capitalization.
• Numbers, dates, times, percentages, and money are consistently formatted: Words are used for numbers zero through nine, numerals for 10 and above, dates follow "Month Day, Year," times are formatted like "10:30am," percentages use %, and money uses currency symbols.
• All original sources are cited using Chicago style: Whenever data is referenced, the original source is cited and linked.
• Writing is bias-free: Content depicts diverse perspectives, avoids stereotypes, and uses gender-neutral terms. Militaristic, exclusionary language is not used. (eg: "sale representative" vs "salesman")
• Writing avoids outdated or inappropriate acronyms: Precise terms are used when referring to specific groups. ("Permit list" vs "Whitelist")
• Writing uses asset-based, specific language: Writing focuses on strengths and potential rather than deficits. (eg: "learners with additional learning needs" vs "special needs learners")

2025-03-06 19:00:16,042 - INFO - ----------------------------------------
2025-03-06 19:00:16,042 - INFO - [user]
2025-03-06 19:00:16,042 - INFO - Generate a complete example solution that rigorously follows the configuration specifications:

USE CASE CONTENT:
{
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case guides you on how to use AI tools by writing precise comments and docstrings that serve as effective prompts for automated code generation. By following research-backed guidelines, you will learn to create clear, detailed function descriptions and specific TODO comments to express your algorithmic intent. This process highlights the importance of natural language clarity, iterative prompt refinement, and validating AI-generated outputs to ensure they match your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Ensure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
    "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
    "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/"
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "snippet": null,
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": 0.75
    }
  ]
}

RESEARCH FINDINGS:
Q: How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?
A: To craft effective code prompts for AI assistance, particularly for Python development using GitHub Copilot with GPT-4, developers should focus on optimizing their docstrings and TODO comments. This approach can significantly enhance communication of complex algorithmic intents and improve the accuracy of AI-generated code. Here's a comprehensive guide on how to achieve this, along with potential pitfalls to be aware of:

## Optimizing Python Docstrings for AI Prompts

### Clear and Concise Function Descriptions

Start your docstrings with a clear, concise description of the function's purpose. This helps the AI understand the overall intent quickly.

```python
def calculate_fibonacci(n):
    """
    Calculate the nth Fibonacci number using dynamic programming.
    """
    # Implementation here
```

### Detailed Parameter Descriptions

Provide detailed descriptions for each parameter, including type hints and expected value ranges.

```python
def process_data(data: List[Dict], threshold: float = 0.5):
    """
    Process a list of data dictionaries based on a threshold value.

    :param data: List of dictionaries containing data points
    :param threshold: Float value between 0 and 1 for filtering (default: 0.5)
    :return: Processed data as a new list of dictionaries
    """
    # Implementation here
```

### Expected Return Values

Clearly state the expected return value(s) and their format.

```python
def analyze_text(text: str) -> Dict[str, Any]:
    """
    Analyze the given text and return various metrics.

    :param text: Input text to analyze
    :return: Dictionary containing:
             - 'word_count': int, number of words
             - 'sentiment': float, sentiment score between -1 and 1
             - 'key_phrases': List[str], important phrases extracted
    """
    # Implementation here
```

### Usage Examples

Include usage examples in the docstring to demonstrate how the function should be called and what to expect.

```python
def create_user(username: str, email: str, age: int) -> Dict[str, Any]:
    """
    Create a new user with the given details.

    :param username: Unique username for the new user
    :param email: Valid email address
    :param age: User's age (must be 18 or older)
    :return: Dictionary containing user details and generated user ID

    Example:
    >>> user = create_user("john_doe", "john@example.com", 25)
    >>> print(user)
    {'id': 'usr_123', 'username': 'john_doe', 'email': 'john@example.com', 'age': 25}
    """
    # Implementation here
```

## Optimizing TODO Comments for AI Prompts

### Specific Action Items

Make TODO comments specific about what needs to be done, providing clear direction for the AI.

```python
# TODO: Implement caching mechanism for API responses to reduce network calls
```

### Context and Constraints

Include relevant context and any constraints in the TODO comment to guide the AI's code generation.

```python
# TODO: Optimize the sorting algorithm for large datasets (>1M elements)
# Consider using a hybrid approach combining quicksort and insertion sort
```

### Expected Behavior

Describe the expected behavior or output of the code to be implemented.

```python
# TODO: Add input validation for the 'process_data' function
# Ensure that 'data' is a non-empty list and 'threshold' is between 0 and 1
```

### References to Relevant Documentation or Standards

Include references to documentation or standards that the implementation should adhere to.

```python
# TODO: Implement OAuth2 authentication flow as per RFC 6749
# Refer to: https://tools.ietf.org/html/rfc6749
```

## Pitfalls to Be Aware Of

1. **Overreliance on AI**: Don't rely solely on AI-generated code. Always review and test the output[4].

2. **Security Vulnerabilities**: AI may inadvertently introduce security vulnerabilities. Thoroughly review generated code for potential security issues[4].

3. **Code Quality Concerns**: AI-generated code may not always adhere to best practices or project-specific standards. Ensure the code meets your quality requirements[4].

4. **Incomplete Context**: Providing insufficient context in prompts can lead to inaccurate or irrelevant code generation[1].

5. **Intellectual Property Issues**: Be cautious about using copyrighted code or algorithms in your prompts, as this may lead to legal issues[3].

6. **Overcomplicating Prompts**: Excessively complex prompts may confuse the AI and result in less accurate code generation[5].

7. **Ignoring Edge Cases**: Ensure your prompts consider edge cases and error handling to generate robust code[2].

8. **Lack of Documentation**: While AI can generate code, it may not always provide adequate inline comments or documentation. Ensure critical parts of the code are well-documented[2].

By following these guidelines and being aware of the potential pitfalls, developers can effectively communicate their programming intent through structured comments and docstrings, leading to more accurate and useful AI-generated code. Remember that while AI tools like GitHub Copilot can significantly enhance productivity, they should be used as assistants rather than replacements for human expertise and judgment in software development.

Q: What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?
A: To craft effective code prompts for AI assistance, developers should follow several best practices to maximize the accuracy of AI-generated code and ensure it aligns with their original intent. Here's a comprehensive guide on structuring prompts and validating the results:

## Structuring Effective Code Prompts

### Be Specific and Contextual

Provide clear, detailed instructions about what you want the AI to generate. Include information about:

- Programming language
- Framework or libraries being used
- Desired functionality
- Input/output expectations
- Any constraints or edge cases to consider

Example:
```
Generate a Python function using the requests library to fetch data from a REST API. The function should handle pagination, rate limiting, and error responses. It should return the data as a list of dictionaries.
```

### Use a Consistent Format

Adopt a consistent structure for your prompts to help the AI understand your requirements better. A common format is:

1. Task description
2. Input parameters
3. Expected output
4. Additional constraints or requirements

Example:
```
Task: Create a sorting algorithm
Input: An unsorted list of integers
Output: A sorted list in ascending order
Constraints: 
- Use the quicksort algorithm
- Optimize for space complexity
- Include comments explaining the logic
```

### Provide Examples

When possible, include sample inputs and expected outputs to guide the AI's understanding:

```
Create a function that calculates the Fibonacci sequence. 
Example input: n = 5
Expected output: [0, 1, 1, 2, 3]
```

### Specify the Coding Style

Mention any specific coding style or conventions you want the AI to follow:

```
Write a Java class following the JavaBeans convention. Use camelCase for method names and include appropriate getter and setter methods.
```

### Request Explanations

Ask the AI to include comments or explanations for complex logic:

```
Implement a binary search tree in C++. Include comments explaining the logic behind insertion, deletion, and traversal operations.
```

## Validating AI-Generated Code

To ensure the AI-generated code matches the original developer intent, consider these validation techniques:

### Code Review

Carefully review the generated code to ensure it meets your requirements. Look for:

- Correct implementation of the requested functionality
- Proper handling of edge cases
- Adherence to specified coding style and conventions

### Test Case Generation

Ask the AI to generate test cases along with the code:

```
Create a function to validate email addresses in JavaScript. Also, provide a set of test cases covering various scenarios, including valid and invalid email formats.
```

### Iterative Refinement

If the initial output doesn't fully meet your needs, iterate on your prompt:

1. Identify specific areas that need improvement
2. Provide feedback to the AI
3. Ask for modifications or enhancements

Example:
```
The previous implementation was good, but it didn't handle the case of empty input. Please modify the function to return an appropriate error message for empty or null inputs.
```

### Live Programming Validation

Utilize live programming environments to immediately test and validate the generated code:

1. Set up a live coding environment (e.g., Jupyter Notebooks for Python)
2. Paste the AI-generated code into the environment
3. Execute the code with various inputs
4. Observe the outputs and behavior in real-time

This approach allows for quick iteration and refinement of both the prompt and the generated code.

### Static Analysis

Run static analysis tools on the generated code to check for:

- Potential bugs or security vulnerabilities
- Adherence to coding standards
- Performance optimizations

### Peer Review

Have other team members review the AI-generated code and the original prompt to ensure it meets team standards and project requirements.

## Best Practices for Inline Chat Prompts

When using inline chat for code generation, consider these additional tips:

1. **Start with a clear objective**: Begin your prompt with a concise statement of what you're trying to achieve.

2. **Use code blocks**: Enclose existing code or expected output in code blocks for clarity.

3. **Break down complex tasks**: For larger features, break them into smaller, manageable prompts.

4. **Reference existing code**: Point the AI to relevant parts of your codebase for context.

5. **Specify error handling**: Explicitly request error handling and edge case management.

6. **Ask for documentation**: Request inline comments or separate documentation for complex logic.

7. **Iterate gradually**: Start with a basic implementation and progressively add complexity through follow-up prompts.

By following these practices, developers can craft more effective prompts for AI code generation, leading to more accurate and useful outputs that align closely with their original intent. Remember that AI assistance is a tool to enhance productivity, but it's crucial to maintain a critical eye and validate all generated code thoroughly before integration into production systems.

Q: In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?
A: To effectively craft code prompts for AI assistance and evaluate the outputs, front-end developers can employ several strategies when using GitHub Copilot. Here's a comprehensive approach to structuring comments, iteratively refining outputs, and measuring alignment with requirements:

## Structuring Effective Code Prompts

### Use Clear and Specific Language

Write comments that clearly state the desired functionality, input/output expectations, and any specific requirements[1]. For example:

```javascript
// Create a React component that renders a responsive image gallery
// - Accept an array of image URLs as a prop
// - Display images in a grid layout (3 columns on desktop, 2 on tablet, 1 on mobile)
// - Implement lazy loading for performance
// - Add click functionality to open images in a lightbox
```

### Provide Context and Constraints

Include relevant information about the project structure, dependencies, or coding standards[1]. For instance:

```javascript
// Using React 18 and Tailwind CSS
// Follow functional component patterns and use hooks
// Ensure accessibility (WCAG 2.1 AA compliance)
```

### Break Down Complex Tasks

For more intricate features, break them into smaller, manageable subtasks[3]. This helps Copilot generate more accurate and focused code:

```javascript
// Step 1: Create a basic grid layout component
// Step 2: Implement responsive design using CSS Grid or Flexbox
// Step 3: Add lazy loading functionality
// Step 4: Implement lightbox feature
```

## Iterative Refinement Process

### 1. Initial Generation

Start with a high-level prompt and let Copilot generate an initial implementation[1].

### 2. Review and Analyze

Carefully examine the generated code, identifying areas that need improvement or don't meet the specified requirements[5].

### 3. Targeted Refinement

Use more specific prompts to address identified issues or add missing functionality[1]. For example:

```javascript
// Refine the lazy loading implementation to use Intersection Observer API
// Ensure images have appropriate alt text for accessibility
```

### 4. Collaborative Improvement

Leverage Copilot Chat to ask questions about the generated code, request explanations, or suggest improvements[9]. For instance:

```
@copilot How can we optimize the image loading performance further?
```

### 5. Manual Adjustments

Make necessary manual edits to fine-tune the code, ensuring it aligns perfectly with your project's needs and coding standards[5].

## Evaluation Criteria

To ensure the generated code meets specified requirements, consider the following measurable criteria:

1. **Functionality Completeness**: Does the code implement all requested features?[5]

2. **Code Quality**: Evaluate metrics such as cyclomatic complexity, maintainability index, and adherence to best practices[7].

3. **Performance**: Measure load times, rendering performance, and resource usage[7].

4. **Accessibility**: Use automated tools to check WCAG compliance levels[9].

5. **Responsiveness**: Test across various device sizes to ensure proper layout adaptation[1].

6. **Browser Compatibility**: Verify functionality across target browsers.

7. **Error Handling**: Assess how well the code handles edge cases and potential errors[5].

8. **Code Consistency**: Ensure the generated code follows project-specific coding standards and patterns[1].

9. **Documentation Quality**: Evaluate the clarity and completeness of inline comments and any generated documentation[2].

10. **Test Coverage**: If tests are generated, measure the percentage of code covered by unit tests[7].

## Measurement Techniques

1. **Automated Testing**: Implement unit tests, integration tests, and end-to-end tests to verify functionality and catch regressions[7].

2. **Code Review Checklists**: Create a standardized checklist based on your evaluation criteria for consistent review processes[5].

3. **Performance Profiling**: Use browser developer tools and specialized profiling software to measure rendering times, memory usage, and other performance metrics[7].

4. **Accessibility Audits**: Employ tools like axe-core or Lighthouse to conduct automated accessibility checks[9].

5. **User Testing**: Gather feedback from real users to assess the usability and effectiveness of the implemented features.

6. **Static Code Analysis**: Utilize tools like ESLint, SonarQube, or GitHub's CodeQL to identify potential issues and measure code quality metrics[7].

7. **Cross-browser Testing**: Use services like BrowserStack or Sauce Labs to verify compatibility across different browsers and devices.

8. **Peer Reviews**: Engage other developers in reviewing the generated code to catch issues that automated tools might miss[5].

By following this structured approach to crafting prompts, iteratively refining outputs, and rigorously evaluating the results, front-end developers can effectively leverage GitHub Copilot to generate high-quality, requirement-aligned code. This process not only improves the accuracy of AI-generated code but also enhances the developer's skills in working with AI coding assistants, a crucial competency in modern software development.


CRITICAL REQUIREMENTS:
1. Solution must be immediately actionable in the configured environment
2. All examples must use exact versions and syntax for specified tools
3. Each step must demonstrate clear value while maintaining technical precision
4. Code and prompts must be production-ready and fully validated

SCHEMA REQUIREMENTS:
- All fields in ExampleSolutionOutput are required
- Each step needs both 'action' and 'code_or_prompt' fields
- Variations list must exist (can be empty for specific configurations)
- Demo script must be a clear 2-3 minute technical walkthrough
- Steps must align exactly with use case steps:
[
  "Write detailed function docstring",
  "Add specific TODO comments",
  "Describe complex logic in natural language",
  "Refine your prompts based on initial output",
  "Validate the generated code"
]

Focus on creating a solution that:
1. Maximizes the capabilities of specified tools and versions
2. Demonstrates best practices for the configured environment
3. Provides clear validation and error handling
4. Can be reproduced exactly as shown
2025-03-06 19:00:16,043 - INFO - ----------------------------------------
2025-03-06 19:00:16,043 - INFO - ================================================================================

2025-03-06 19:00:54,173 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-03-06 19:00:54,519 - INFO - 
================================================================================
2025-03-06 19:00:54,519 - INFO - STEP: 5 - Example Solution Generation
2025-03-06 19:00:54,519 - INFO - --------------------------------------------------------------------------------
2025-03-06 19:00:54,519 - INFO - PROMPT:
2025-03-06 19:00:54,519 - INFO - ----------------------------------------
2025-03-06 19:00:54,519 - INFO - Generate a complete example solution that rigorously follows the configuration specifications:

USE CASE CONTENT:
{
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case guides you on how to use AI tools by writing precise comments and docstrings that serve as effective prompts for automated code generation. By following research-backed guidelines, you will learn to create clear, detailed function descriptions and specific TODO comments to express your algorithmic intent. This process highlights the importance of natural language clarity, iterative prompt refinement, and validating AI-generated outputs to ensure they match your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Ensure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
    "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
    "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/"
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "snippet": null,
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": 0.75
    }
  ]
}

RESEARCH FINDINGS:
Q: How can developers optimize Python docstrings and TODO comments to effectively communicate complex algorithmic intents via GitHub Copilot using GPT-4o, and what pitfalls should they be aware of in this prompting approach?
A: To craft effective code prompts for AI assistance, particularly for Python development using GitHub Copilot with GPT-4, developers should focus on optimizing their docstrings and TODO comments. This approach can significantly enhance communication of complex algorithmic intents and improve the accuracy of AI-generated code. Here's a comprehensive guide on how to achieve this, along with potential pitfalls to be aware of:

## Optimizing Python Docstrings for AI Prompts

### Clear and Concise Function Descriptions

Start your docstrings with a clear, concise description of the function's purpose. This helps the AI understand the overall intent quickly.

```python
def calculate_fibonacci(n):
    """
    Calculate the nth Fibonacci number using dynamic programming.
    """
    # Implementation here
```

### Detailed Parameter Descriptions

Provide detailed descriptions for each parameter, including type hints and expected value ranges.

```python
def process_data(data: List[Dict], threshold: float = 0.5):
    """
    Process a list of data dictionaries based on a threshold value.

    :param data: List of dictionaries containing data points
    :param threshold: Float value between 0 and 1 for filtering (default: 0.5)
    :return: Processed data as a new list of dictionaries
    """
    # Implementation here
```

### Expected Return Values

Clearly state the expected return value(s) and their format.

```python
def analyze_text(text: str) -> Dict[str, Any]:
    """
    Analyze the given text and return various metrics.

    :param text: Input text to analyze
    :return: Dictionary containing:
             - 'word_count': int, number of words
             - 'sentiment': float, sentiment score between -1 and 1
             - 'key_phrases': List[str], important phrases extracted
    """
    # Implementation here
```

### Usage Examples

Include usage examples in the docstring to demonstrate how the function should be called and what to expect.

```python
def create_user(username: str, email: str, age: int) -> Dict[str, Any]:
    """
    Create a new user with the given details.

    :param username: Unique username for the new user
    :param email: Valid email address
    :param age: User's age (must be 18 or older)
    :return: Dictionary containing user details and generated user ID

    Example:
    >>> user = create_user("john_doe", "john@example.com", 25)
    >>> print(user)
    {'id': 'usr_123', 'username': 'john_doe', 'email': 'john@example.com', 'age': 25}
    """
    # Implementation here
```

## Optimizing TODO Comments for AI Prompts

### Specific Action Items

Make TODO comments specific about what needs to be done, providing clear direction for the AI.

```python
# TODO: Implement caching mechanism for API responses to reduce network calls
```

### Context and Constraints

Include relevant context and any constraints in the TODO comment to guide the AI's code generation.

```python
# TODO: Optimize the sorting algorithm for large datasets (>1M elements)
# Consider using a hybrid approach combining quicksort and insertion sort
```

### Expected Behavior

Describe the expected behavior or output of the code to be implemented.

```python
# TODO: Add input validation for the 'process_data' function
# Ensure that 'data' is a non-empty list and 'threshold' is between 0 and 1
```

### References to Relevant Documentation or Standards

Include references to documentation or standards that the implementation should adhere to.

```python
# TODO: Implement OAuth2 authentication flow as per RFC 6749
# Refer to: https://tools.ietf.org/html/rfc6749
```

## Pitfalls to Be Aware Of

1. **Overreliance on AI**: Don't rely solely on AI-generated code. Always review and test the output[4].

2. **Security Vulnerabilities**: AI may inadvertently introduce security vulnerabilities. Thoroughly review generated code for potential security issues[4].

3. **Code Quality Concerns**: AI-generated code may not always adhere to best practices or project-specific standards. Ensure the code meets your quality requirements[4].

4. **Incomplete Context**: Providing insufficient context in prompts can lead to inaccurate or irrelevant code generation[1].

5. **Intellectual Property Issues**: Be cautious about using copyrighted code or algorithms in your prompts, as this may lead to legal issues[3].

6. **Overcomplicating Prompts**: Excessively complex prompts may confuse the AI and result in less accurate code generation[5].

7. **Ignoring Edge Cases**: Ensure your prompts consider edge cases and error handling to generate robust code[2].

8. **Lack of Documentation**: While AI can generate code, it may not always provide adequate inline comments or documentation. Ensure critical parts of the code are well-documented[2].

By following these guidelines and being aware of the potential pitfalls, developers can effectively communicate their programming intent through structured comments and docstrings, leading to more accurate and useful AI-generated code. Remember that while AI tools like GitHub Copilot can significantly enhance productivity, they should be used as assistants rather than replacements for human expertise and judgment in software development.

Q: What are the current best practices for structuring natural language prompts in inline chat to maximize the accuracy of AI-generated code, and how can these be validated against the original developer intent?
A: To craft effective code prompts for AI assistance, developers should follow several best practices to maximize the accuracy of AI-generated code and ensure it aligns with their original intent. Here's a comprehensive guide on structuring prompts and validating the results:

## Structuring Effective Code Prompts

### Be Specific and Contextual

Provide clear, detailed instructions about what you want the AI to generate. Include information about:

- Programming language
- Framework or libraries being used
- Desired functionality
- Input/output expectations
- Any constraints or edge cases to consider

Example:
```
Generate a Python function using the requests library to fetch data from a REST API. The function should handle pagination, rate limiting, and error responses. It should return the data as a list of dictionaries.
```

### Use a Consistent Format

Adopt a consistent structure for your prompts to help the AI understand your requirements better. A common format is:

1. Task description
2. Input parameters
3. Expected output
4. Additional constraints or requirements

Example:
```
Task: Create a sorting algorithm
Input: An unsorted list of integers
Output: A sorted list in ascending order
Constraints: 
- Use the quicksort algorithm
- Optimize for space complexity
- Include comments explaining the logic
```

### Provide Examples

When possible, include sample inputs and expected outputs to guide the AI's understanding:

```
Create a function that calculates the Fibonacci sequence. 
Example input: n = 5
Expected output: [0, 1, 1, 2, 3]
```

### Specify the Coding Style

Mention any specific coding style or conventions you want the AI to follow:

```
Write a Java class following the JavaBeans convention. Use camelCase for method names and include appropriate getter and setter methods.
```

### Request Explanations

Ask the AI to include comments or explanations for complex logic:

```
Implement a binary search tree in C++. Include comments explaining the logic behind insertion, deletion, and traversal operations.
```

## Validating AI-Generated Code

To ensure the AI-generated code matches the original developer intent, consider these validation techniques:

### Code Review

Carefully review the generated code to ensure it meets your requirements. Look for:

- Correct implementation of the requested functionality
- Proper handling of edge cases
- Adherence to specified coding style and conventions

### Test Case Generation

Ask the AI to generate test cases along with the code:

```
Create a function to validate email addresses in JavaScript. Also, provide a set of test cases covering various scenarios, including valid and invalid email formats.
```

### Iterative Refinement

If the initial output doesn't fully meet your needs, iterate on your prompt:

1. Identify specific areas that need improvement
2. Provide feedback to the AI
3. Ask for modifications or enhancements

Example:
```
The previous implementation was good, but it didn't handle the case of empty input. Please modify the function to return an appropriate error message for empty or null inputs.
```

### Live Programming Validation

Utilize live programming environments to immediately test and validate the generated code:

1. Set up a live coding environment (e.g., Jupyter Notebooks for Python)
2. Paste the AI-generated code into the environment
3. Execute the code with various inputs
4. Observe the outputs and behavior in real-time

This approach allows for quick iteration and refinement of both the prompt and the generated code.

### Static Analysis

Run static analysis tools on the generated code to check for:

- Potential bugs or security vulnerabilities
- Adherence to coding standards
- Performance optimizations

### Peer Review

Have other team members review the AI-generated code and the original prompt to ensure it meets team standards and project requirements.

## Best Practices for Inline Chat Prompts

When using inline chat for code generation, consider these additional tips:

1. **Start with a clear objective**: Begin your prompt with a concise statement of what you're trying to achieve.

2. **Use code blocks**: Enclose existing code or expected output in code blocks for clarity.

3. **Break down complex tasks**: For larger features, break them into smaller, manageable prompts.

4. **Reference existing code**: Point the AI to relevant parts of your codebase for context.

5. **Specify error handling**: Explicitly request error handling and edge case management.

6. **Ask for documentation**: Request inline comments or separate documentation for complex logic.

7. **Iterate gradually**: Start with a basic implementation and progressively add complexity through follow-up prompts.

By following these practices, developers can craft more effective prompts for AI code generation, leading to more accurate and useful outputs that align closely with their original intent. Remember that AI assistance is a tool to enhance productivity, but it's crucial to maintain a critical eye and validate all generated code thoroughly before integration into production systems.

Q: In what ways can front-end developers iteratively refine and evaluate AI code generation outputs on GitHub Copilot by leveraging structured comments, and what measurable criteria can ensure alignment with specified requirements?
A: To effectively craft code prompts for AI assistance and evaluate the outputs, front-end developers can employ several strategies when using GitHub Copilot. Here's a comprehensive approach to structuring comments, iteratively refining outputs, and measuring alignment with requirements:

## Structuring Effective Code Prompts

### Use Clear and Specific Language

Write comments that clearly state the desired functionality, input/output expectations, and any specific requirements[1]. For example:

```javascript
// Create a React component that renders a responsive image gallery
// - Accept an array of image URLs as a prop
// - Display images in a grid layout (3 columns on desktop, 2 on tablet, 1 on mobile)
// - Implement lazy loading for performance
// - Add click functionality to open images in a lightbox
```

### Provide Context and Constraints

Include relevant information about the project structure, dependencies, or coding standards[1]. For instance:

```javascript
// Using React 18 and Tailwind CSS
// Follow functional component patterns and use hooks
// Ensure accessibility (WCAG 2.1 AA compliance)
```

### Break Down Complex Tasks

For more intricate features, break them into smaller, manageable subtasks[3]. This helps Copilot generate more accurate and focused code:

```javascript
// Step 1: Create a basic grid layout component
// Step 2: Implement responsive design using CSS Grid or Flexbox
// Step 3: Add lazy loading functionality
// Step 4: Implement lightbox feature
```

## Iterative Refinement Process

### 1. Initial Generation

Start with a high-level prompt and let Copilot generate an initial implementation[1].

### 2. Review and Analyze

Carefully examine the generated code, identifying areas that need improvement or don't meet the specified requirements[5].

### 3. Targeted Refinement

Use more specific prompts to address identified issues or add missing functionality[1]. For example:

```javascript
// Refine the lazy loading implementation to use Intersection Observer API
// Ensure images have appropriate alt text for accessibility
```

### 4. Collaborative Improvement

Leverage Copilot Chat to ask questions about the generated code, request explanations, or suggest improvements[9]. For instance:

```
@copilot How can we optimize the image loading performance further?
```

### 5. Manual Adjustments

Make necessary manual edits to fine-tune the code, ensuring it aligns perfectly with your project's needs and coding standards[5].

## Evaluation Criteria

To ensure the generated code meets specified requirements, consider the following measurable criteria:

1. **Functionality Completeness**: Does the code implement all requested features?[5]

2. **Code Quality**: Evaluate metrics such as cyclomatic complexity, maintainability index, and adherence to best practices[7].

3. **Performance**: Measure load times, rendering performance, and resource usage[7].

4. **Accessibility**: Use automated tools to check WCAG compliance levels[9].

5. **Responsiveness**: Test across various device sizes to ensure proper layout adaptation[1].

6. **Browser Compatibility**: Verify functionality across target browsers.

7. **Error Handling**: Assess how well the code handles edge cases and potential errors[5].

8. **Code Consistency**: Ensure the generated code follows project-specific coding standards and patterns[1].

9. **Documentation Quality**: Evaluate the clarity and completeness of inline comments and any generated documentation[2].

10. **Test Coverage**: If tests are generated, measure the percentage of code covered by unit tests[7].

## Measurement Techniques

1. **Automated Testing**: Implement unit tests, integration tests, and end-to-end tests to verify functionality and catch regressions[7].

2. **Code Review Checklists**: Create a standardized checklist based on your evaluation criteria for consistent review processes[5].

3. **Performance Profiling**: Use browser developer tools and specialized profiling software to measure rendering times, memory usage, and other performance metrics[7].

4. **Accessibility Audits**: Employ tools like axe-core or Lighthouse to conduct automated accessibility checks[9].

5. **User Testing**: Gather feedback from real users to assess the usability and effectiveness of the implemented features.

6. **Static Code Analysis**: Utilize tools like ESLint, SonarQube, or GitHub's CodeQL to identify potential issues and measure code quality metrics[7].

7. **Cross-browser Testing**: Use services like BrowserStack or Sauce Labs to verify compatibility across different browsers and devices.

8. **Peer Reviews**: Engage other developers in reviewing the generated code to catch issues that automated tools might miss[5].

By following this structured approach to crafting prompts, iteratively refining outputs, and rigorously evaluating the results, front-end developers can effectively leverage GitHub Copilot to generate high-quality, requirement-aligned code. This process not only improves the accuracy of AI-generated code but also enhances the developer's skills in working with AI coding assistants, a crucial competency in modern software development.


CRITICAL REQUIREMENTS:
1. Solution must be immediately actionable in the configured environment
2. All examples must use exact versions and syntax for specified tools
3. Each step must demonstrate clear value while maintaining technical precision
4. Code and prompts must be production-ready and fully validated

SCHEMA REQUIREMENTS:
- All fields in ExampleSolutionOutput are required
- Each step needs both 'action' and 'code_or_prompt' fields
- Variations list must exist (can be empty for specific configurations)
- Demo script must be a clear 2-3 minute technical walkthrough
- Steps must align exactly with use case steps:
[
  "Write detailed function docstring",
  "Add specific TODO comments",
  "Describe complex logic in natural language",
  "Refine your prompts based on initial output",
  "Validate the generated code"
]

Focus on creating a solution that:
1. Maximizes the capabilities of specified tools and versions
2. Demonstrates best practices for the configured environment
3. Provides clear validation and error handling
4. Can be reproduced exactly as shown
2025-03-06 19:00:54,520 - INFO - ----------------------------------------
2025-03-06 19:00:54,520 - INFO - RESPONSE:
2025-03-06 19:00:54,520 - INFO - ----------------------------------------
2025-03-06 19:00:54,520 - INFO - {
  "metadata": {
    "id": "CORE-02",
    "ai_tool": "GitHub Copilot",
    "family": "Core Skills",
    "status": "active",
    "complexity_level": "Intermediate",
    "customization_level": "Standard",
    "time_minutes": 20,
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "notes": "This solution demonstrates effective code prompting in an inline chat environment using GitHub Copilot with GPT-4o.",
    "tool": "GitHub Copilot",
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "solution": {
    "title": "Craft Effective Code Prompts for AI Assistance",
    "setup_time": 3,
    "demo_time": 3,
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "scenario": "A front-end developer utilizes GitHub Copilot in inline chat mode powered by GPT-4o to iteratively generate and improve Python code. The developer writes detailed docstrings, adds specific TODO comments, clearly explains complex logic in plain language, refines prompts based on initial outputs, and validates the final code through testing.",
    "steps": [
      {
        "action": "Write detailed function docstring: Compose a comprehensive Python function docstring that details the function's purpose, parameters, return values, and usage examples to guide the AI.",
        "code_or_prompt": "def calculate_discounted_price(price, discount):\n    \"\"\"\n    Calculate the final price after applying a discount.\n\n    Parameters:\n        price (float): The original price of the item. Must be non-negative.\n        discount (float): Discount rate as a float between 0 and 1 (e.g., 0.20 for 20% discount).\n\n    Returns:\n        float: Final price after discount. Returns 0 if discount is 1.\n\n    Example:\n        >>> calculate_discounted_price(100.0, 0.2)\n        80.0\n    \"\"\"\n    return price * (1 - discount)"
      },
      {
        "action": "Add specific TODO comments: Insert inline TODO comments that clearly outline specific algorithmic tasks and constraints.",
        "code_or_prompt": "def fetch_user_data(user_id: int) -> dict:\n    \"\"\"Fetch user data from the database using a unique user ID.\"\"\"\n    # TODO: Establish a secure connection to the user database\n    # TODO: Execute an SQL query to retrieve user details\n    # TODO: Implement error handling for connection timeouts and query failures\n    # TODO: Validate the format of the returned data\n    return {}"
      },
      {
        "action": "Describe complex logic in natural language: Explain the detailed logic behind a function in plain language to ensure clarity before implementation.",
        "code_or_prompt": "def sort_numbers(numbers: list) -> list:\n    \"\"\"Sort a list of numbers using the merge sort algorithm.\"\"\"\n    # The merge sort algorithm works as follows:\n    # 1. If the list has zero or one element, it is already sorted.\n    # 2. Divide the list into two nearly equal halves.\n    # 3. Recursively sort each half.\n    # 4. Merge the two sorted halves by comparing the smallest elements from each.\n    # 5. Return the fully merged and sorted list.\n    if len(numbers) <= 1:\n        return numbers\n    mid = len(numbers) // 2\n    left = sort_numbers(numbers[:mid])\n    right = sort_numbers(numbers[mid:])\n    sorted_list = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n    return sorted_list"
      },
      {
        "action": "Refine your prompts based on initial output: Review the AI-generated code and adjust your prompts with added clarifications for error handling and edge cases.",
        "code_or_prompt": "# Initial review of the fetch_user_data function revealed missing input validation and error handling for invalid user IDs.\n# Refined prompt for GitHub Copilot:\n\"@copilot, update the fetch_user_data function to include validation that the user_id is a positive integer and add try-except blocks to handle potential database errors.\""
      },
      {
        "action": "Validate the generated code: Test and review the code to ensure it meets functional requirements and handles edge cases appropriately.",
        "code_or_prompt": "if __name__ == '__main__':\n    # Validate calculate_discounted_price function\n    result = calculate_discounted_price(100.0, 0.2)\n    print('Discounted Price:', result)  # Expected output: 80.0\n\n    # Validate sort_numbers function\n    test_numbers = [34, 7, 23, 32, 5, 62]\n    sorted_numbers = sort_numbers(test_numbers)\n    print('Sorted Numbers:', sorted_numbers)  # Expected sorted list: [5, 7, 23, 32, 34, 62]\n\n    # Further testing and manual code review should be performed to ensure all edge cases and error handling are in place."
      }
    ],
    "validation": [
      "Run the main block to verify the expected outputs for each function.",
      "Inspect inline comments and TODO items to confirm they guide the AI effectively.",
      "Verify that GitHub Copilot's refined suggestions address initial shortcomings.",
      "Conduct manual code reviews and run unit tests to cover error handling and edge cases."
    ],
    "key_points": [
      "Craft clear and comprehensive docstrings as effective AI prompts.",
      "Include specific and actionable TODO comments.",
      "Describe complex logic in plain natural language.",
      "Iteratively refine prompts based on AI output feedback.",
      "Validate generated code through thorough testing and reviews."
    ],
    "common_issues": [
      "Ambiguous prompts may not capture all functional requirements.",
      "Overreliance on auto-generated code without manual validation.",
      "Insufficient error handling or unclear TODO instructions.",
      "Missing detailed inline explanations can reduce code clarity."
    ],
    "variations": []
  },
  "demo_script": "Welcome to this demo on crafting effective code prompts for AI assistance using GitHub Copilot with GPT-4o. In this 2-3 minute walkthrough, you'll see how to start by writing a detailed function docstring that defines a function's purpose, parameters, and return values. Next, you'll add specific TODO comments that precisely outline each task and constraint. We'll then describe complex logic in plain language to guide the AI in generating robust code. After reviewing the initial output from Copilot, you'll refine your prompts to handle edge cases and improve error handling. Finally, you'll validate the generated code by running tests and reviewing the outputs to ensure everything meets your requirements. Follow along with the provided Python examples to reproduce this process in your own projects."
}
2025-03-06 19:00:54,520 - INFO - ================================================================================

2025-03-06 19:00:54,521 - INFO - 
Completed step 5: Example solution generation
2025-03-06 19:00:54,521 - INFO - 
================================================================================
2025-03-06 19:00:54,521 - INFO - INITIATING STEP: 6 - Visual Elements Suggestions
2025-03-06 19:00:54,521 - INFO - --------------------------------------------------------------------------------
2025-03-06 19:00:54,521 - INFO - FULL PROMPT:
2025-03-06 19:00:54,521 - INFO - ----------------------------------------
2025-03-06 19:00:54,521 - INFO - [system]
2025-03-06 19:00:54,521 - INFO - You are an instructional designer creating visual element suggestions for a software development use case. Your goal is to propose specific visual aids that enhance understanding while maintaining technical accuracy.

VISUAL ELEMENT GUIDELINES:
1. Tool-Specific Visualization:
   - Focus on interface elements unique to specified tools
   - Capture version-specific features when relevant
   - Show actual tool interactions and outputs

2. Technical Accuracy:
   - All code snippets must match specified language and versions
   - Screenshots should reflect current tool interfaces
   - Diagrams must align with documented workflows

3. Educational Value:
   - Each visual must serve a clear learning purpose
   - Complex concepts should be broken down visually
   - Key steps should have supporting visuals

CRITICAL REQUIREMENTS:
- All suggestions must align with the subject matter and steps
- Visual elements must be reproducible in the specified environment
- Focus on practical, high-impact visualizations


• Content is written at an 8th-grade reading level: Content is easy for anyone to understand.
• Content is written in the active voice: Writing empowers learners to find solutions and take action. Passive voice is avoided.
• Content addresses the reader as "you": Point of view is consistent and avoids third-person references like "business leaders" or "apprentices."
• Content is written in a conversational tone: The tone is action-oriented, clear, and energized. Content should assume the knowledge of an average junior developer and minimize the use of unnecessary jargon. Define any terms or processes that are more complex or advanced.
• Content is in US English: Content follows US spelling, grammar, and punctuation unless written explicitly for a UK-based audience.
• Content is concise: Writing is focused and to-the-point.
• Content is broken into digestible sections. Text that is longer than a sentence is broken down into bullets.
• Bullets, headings, and formatting help scanning: Formatting makes content easy to navigate and understand.
• Content is free of spelling, grammar, and punctuation errors: Writing adheres to professional standards.
• Grammar and punctuation follow the Chicago Manual of Style: There is consistency across all content.
• Sentence case is used for all titles and headings: Titles and headings are formatted with minimal capitalization.
• Numbers, dates, times, percentages, and money are consistently formatted: Words are used for numbers zero through nine, numerals for 10 and above, dates follow "Month Day, Year," times are formatted like "10:30am," percentages use %, and money uses currency symbols.
• All original sources are cited using Chicago style: Whenever data is referenced, the original source is cited and linked.
• Writing is bias-free: Content depicts diverse perspectives, avoids stereotypes, and uses gender-neutral terms. Militaristic, exclusionary language is not used. (eg: "sale representative" vs "salesman")
• Writing avoids outdated or inappropriate acronyms: Precise terms are used when referring to specific groups. ("Permit list" vs "Whitelist")
• Writing uses asset-based, specific language: Writing focuses on strengths and potential rather than deficits. (eg: "learners with additional learning needs" vs "special needs learners")


2025-03-06 19:00:54,521 - INFO - ----------------------------------------
2025-03-06 19:00:54,521 - INFO - [user]
2025-03-06 19:00:54,521 - INFO - Review the use case and example solution to suggest visual elements that enhance learning and comprehension.
Focus particularly on visualizing tool-specific interactions and technical concepts.

Final Use Case JSON:
{
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case guides you on how to use AI tools by writing precise comments and docstrings that serve as effective prompts for automated code generation. By following research-backed guidelines, you will learn to create clear, detailed function descriptions and specific TODO comments to express your algorithmic intent. This process highlights the importance of natural language clarity, iterative prompt refinement, and validating AI-generated outputs to ensure they match your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Ensure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
    "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
    "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/"
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "snippet": null,
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": 0.75
    }
  ]
}

Example Solution JSON:
{
  "metadata": {
    "id": "CORE-02",
    "ai_tool": "GitHub Copilot",
    "family": "Core Skills",
    "status": "active",
    "complexity_level": "Intermediate",
    "customization_level": "Standard",
    "time_minutes": 20,
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "notes": "This solution demonstrates effective code prompting in an inline chat environment using GitHub Copilot with GPT-4o.",
    "tool": "GitHub Copilot",
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "solution": {
    "title": "Craft Effective Code Prompts for AI Assistance",
    "setup_time": 3,
    "demo_time": 3,
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "scenario": "A front-end developer utilizes GitHub Copilot in inline chat mode powered by GPT-4o to iteratively generate and improve Python code. The developer writes detailed docstrings, adds specific TODO comments, clearly explains complex logic in plain language, refines prompts based on initial outputs, and validates the final code through testing.",
    "steps": [
      {
        "action": "Write detailed function docstring: Compose a comprehensive Python function docstring that details the function's purpose, parameters, return values, and usage examples to guide the AI.",
        "code_or_prompt": "def calculate_discounted_price(price, discount):\n    \"\"\"\n    Calculate the final price after applying a discount.\n\n    Parameters:\n        price (float): The original price of the item. Must be non-negative.\n        discount (float): Discount rate as a float between 0 and 1 (e.g., 0.20 for 20% discount).\n\n    Returns:\n        float: Final price after discount. Returns 0 if discount is 1.\n\n    Example:\n        >>> calculate_discounted_price(100.0, 0.2)\n        80.0\n    \"\"\"\n    return price * (1 - discount)"
      },
      {
        "action": "Add specific TODO comments: Insert inline TODO comments that clearly outline specific algorithmic tasks and constraints.",
        "code_or_prompt": "def fetch_user_data(user_id: int) -> dict:\n    \"\"\"Fetch user data from the database using a unique user ID.\"\"\"\n    # TODO: Establish a secure connection to the user database\n    # TODO: Execute an SQL query to retrieve user details\n    # TODO: Implement error handling for connection timeouts and query failures\n    # TODO: Validate the format of the returned data\n    return {}"
      },
      {
        "action": "Describe complex logic in natural language: Explain the detailed logic behind a function in plain language to ensure clarity before implementation.",
        "code_or_prompt": "def sort_numbers(numbers: list) -> list:\n    \"\"\"Sort a list of numbers using the merge sort algorithm.\"\"\"\n    # The merge sort algorithm works as follows:\n    # 1. If the list has zero or one element, it is already sorted.\n    # 2. Divide the list into two nearly equal halves.\n    # 3. Recursively sort each half.\n    # 4. Merge the two sorted halves by comparing the smallest elements from each.\n    # 5. Return the fully merged and sorted list.\n    if len(numbers) <= 1:\n        return numbers\n    mid = len(numbers) // 2\n    left = sort_numbers(numbers[:mid])\n    right = sort_numbers(numbers[mid:])\n    sorted_list = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n    return sorted_list"
      },
      {
        "action": "Refine your prompts based on initial output: Review the AI-generated code and adjust your prompts with added clarifications for error handling and edge cases.",
        "code_or_prompt": "# Initial review of the fetch_user_data function revealed missing input validation and error handling for invalid user IDs.\n# Refined prompt for GitHub Copilot:\n\"@copilot, update the fetch_user_data function to include validation that the user_id is a positive integer and add try-except blocks to handle potential database errors.\""
      },
      {
        "action": "Validate the generated code: Test and review the code to ensure it meets functional requirements and handles edge cases appropriately.",
        "code_or_prompt": "if __name__ == '__main__':\n    # Validate calculate_discounted_price function\n    result = calculate_discounted_price(100.0, 0.2)\n    print('Discounted Price:', result)  # Expected output: 80.0\n\n    # Validate sort_numbers function\n    test_numbers = [34, 7, 23, 32, 5, 62]\n    sorted_numbers = sort_numbers(test_numbers)\n    print('Sorted Numbers:', sorted_numbers)  # Expected sorted list: [5, 7, 23, 32, 34, 62]\n\n    # Further testing and manual code review should be performed to ensure all edge cases and error handling are in place."
      }
    ],
    "validation": [
      "Run the main block to verify the expected outputs for each function.",
      "Inspect inline comments and TODO items to confirm they guide the AI effectively.",
      "Verify that GitHub Copilot's refined suggestions address initial shortcomings.",
      "Conduct manual code reviews and run unit tests to cover error handling and edge cases."
    ],
    "key_points": [
      "Craft clear and comprehensive docstrings as effective AI prompts.",
      "Include specific and actionable TODO comments.",
      "Describe complex logic in plain natural language.",
      "Iteratively refine prompts based on AI output feedback.",
      "Validate generated code through thorough testing and reviews."
    ],
    "common_issues": [
      "Ambiguous prompts may not capture all functional requirements.",
      "Overreliance on auto-generated code without manual validation.",
      "Insufficient error handling or unclear TODO instructions.",
      "Missing detailed inline explanations can reduce code clarity."
    ],
    "variations": []
  },
  "demo_script": "Welcome to this demo on crafting effective code prompts for AI assistance using GitHub Copilot with GPT-4o. In this 2-3 minute walkthrough, you'll see how to start by writing a detailed function docstring that defines a function's purpose, parameters, and return values. Next, you'll add specific TODO comments that precisely outline each task and constraint. We'll then describe complex logic in plain language to guide the AI in generating robust code. After reviewing the initial output from Copilot, you'll refine your prompts to handle edge cases and improve error handling. Finally, you'll validate the generated code by running tests and reviewing the outputs to ensure everything meets your requirements. Follow along with the provided Python examples to reproduce this process in your own projects."
}

For each suggested visual element (3-5 total), provide:
1. Specific description of what to capture
2. Technical requirements (tools, versions, settings)
3. Clear explanation of educational value
4. Step or concept it supports
5. Format recommendation (screenshot, GIF, diagram, etc.)

Ensure all suggestions:
- Match the specified tool versions and environments
- Support key learning objectives
- Can be easily reproduced
- Add genuine educational value

2025-03-06 19:00:54,522 - INFO - ----------------------------------------
2025-03-06 19:00:54,522 - INFO - ================================================================================

2025-03-06 19:01:17,837 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2025-03-06 19:01:17,840 - INFO - 
================================================================================
2025-03-06 19:01:17,840 - INFO - STEP: 6 - Visual Elements Suggestions
2025-03-06 19:01:17,840 - INFO - --------------------------------------------------------------------------------
2025-03-06 19:01:17,840 - INFO - PROMPT:
2025-03-06 19:01:17,840 - INFO - ----------------------------------------
2025-03-06 19:01:17,840 - INFO - Review the use case and example solution to suggest visual elements that enhance learning and comprehension.
Focus particularly on visualizing tool-specific interactions and technical concepts.

Final Use Case JSON:
{
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case guides you on how to use AI tools by writing precise comments and docstrings that serve as effective prompts for automated code generation. By following research-backed guidelines, you will learn to create clear, detailed function descriptions and specific TODO comments to express your algorithmic intent. This process highlights the importance of natural language clarity, iterative prompt refinement, and validating AI-generated outputs to ensure they match your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Ensure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
    "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
    "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/"
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "snippet": null,
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": 0.75
    }
  ]
}

Example Solution JSON:
{
  "metadata": {
    "id": "CORE-02",
    "ai_tool": "GitHub Copilot",
    "family": "Core Skills",
    "status": "active",
    "complexity_level": "Intermediate",
    "customization_level": "Standard",
    "time_minutes": 20,
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "notes": "This solution demonstrates effective code prompting in an inline chat environment using GitHub Copilot with GPT-4o.",
    "tool": "GitHub Copilot",
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "solution": {
    "title": "Craft Effective Code Prompts for AI Assistance",
    "setup_time": 3,
    "demo_time": 3,
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "scenario": "A front-end developer utilizes GitHub Copilot in inline chat mode powered by GPT-4o to iteratively generate and improve Python code. The developer writes detailed docstrings, adds specific TODO comments, clearly explains complex logic in plain language, refines prompts based on initial outputs, and validates the final code through testing.",
    "steps": [
      {
        "action": "Write detailed function docstring: Compose a comprehensive Python function docstring that details the function's purpose, parameters, return values, and usage examples to guide the AI.",
        "code_or_prompt": "def calculate_discounted_price(price, discount):\n    \"\"\"\n    Calculate the final price after applying a discount.\n\n    Parameters:\n        price (float): The original price of the item. Must be non-negative.\n        discount (float): Discount rate as a float between 0 and 1 (e.g., 0.20 for 20% discount).\n\n    Returns:\n        float: Final price after discount. Returns 0 if discount is 1.\n\n    Example:\n        >>> calculate_discounted_price(100.0, 0.2)\n        80.0\n    \"\"\"\n    return price * (1 - discount)"
      },
      {
        "action": "Add specific TODO comments: Insert inline TODO comments that clearly outline specific algorithmic tasks and constraints.",
        "code_or_prompt": "def fetch_user_data(user_id: int) -> dict:\n    \"\"\"Fetch user data from the database using a unique user ID.\"\"\"\n    # TODO: Establish a secure connection to the user database\n    # TODO: Execute an SQL query to retrieve user details\n    # TODO: Implement error handling for connection timeouts and query failures\n    # TODO: Validate the format of the returned data\n    return {}"
      },
      {
        "action": "Describe complex logic in natural language: Explain the detailed logic behind a function in plain language to ensure clarity before implementation.",
        "code_or_prompt": "def sort_numbers(numbers: list) -> list:\n    \"\"\"Sort a list of numbers using the merge sort algorithm.\"\"\"\n    # The merge sort algorithm works as follows:\n    # 1. If the list has zero or one element, it is already sorted.\n    # 2. Divide the list into two nearly equal halves.\n    # 3. Recursively sort each half.\n    # 4. Merge the two sorted halves by comparing the smallest elements from each.\n    # 5. Return the fully merged and sorted list.\n    if len(numbers) <= 1:\n        return numbers\n    mid = len(numbers) // 2\n    left = sort_numbers(numbers[:mid])\n    right = sort_numbers(numbers[mid:])\n    sorted_list = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n    return sorted_list"
      },
      {
        "action": "Refine your prompts based on initial output: Review the AI-generated code and adjust your prompts with added clarifications for error handling and edge cases.",
        "code_or_prompt": "# Initial review of the fetch_user_data function revealed missing input validation and error handling for invalid user IDs.\n# Refined prompt for GitHub Copilot:\n\"@copilot, update the fetch_user_data function to include validation that the user_id is a positive integer and add try-except blocks to handle potential database errors.\""
      },
      {
        "action": "Validate the generated code: Test and review the code to ensure it meets functional requirements and handles edge cases appropriately.",
        "code_or_prompt": "if __name__ == '__main__':\n    # Validate calculate_discounted_price function\n    result = calculate_discounted_price(100.0, 0.2)\n    print('Discounted Price:', result)  # Expected output: 80.0\n\n    # Validate sort_numbers function\n    test_numbers = [34, 7, 23, 32, 5, 62]\n    sorted_numbers = sort_numbers(test_numbers)\n    print('Sorted Numbers:', sorted_numbers)  # Expected sorted list: [5, 7, 23, 32, 34, 62]\n\n    # Further testing and manual code review should be performed to ensure all edge cases and error handling are in place."
      }
    ],
    "validation": [
      "Run the main block to verify the expected outputs for each function.",
      "Inspect inline comments and TODO items to confirm they guide the AI effectively.",
      "Verify that GitHub Copilot's refined suggestions address initial shortcomings.",
      "Conduct manual code reviews and run unit tests to cover error handling and edge cases."
    ],
    "key_points": [
      "Craft clear and comprehensive docstrings as effective AI prompts.",
      "Include specific and actionable TODO comments.",
      "Describe complex logic in plain natural language.",
      "Iteratively refine prompts based on AI output feedback.",
      "Validate generated code through thorough testing and reviews."
    ],
    "common_issues": [
      "Ambiguous prompts may not capture all functional requirements.",
      "Overreliance on auto-generated code without manual validation.",
      "Insufficient error handling or unclear TODO instructions.",
      "Missing detailed inline explanations can reduce code clarity."
    ],
    "variations": []
  },
  "demo_script": "Welcome to this demo on crafting effective code prompts for AI assistance using GitHub Copilot with GPT-4o. In this 2-3 minute walkthrough, you'll see how to start by writing a detailed function docstring that defines a function's purpose, parameters, and return values. Next, you'll add specific TODO comments that precisely outline each task and constraint. We'll then describe complex logic in plain language to guide the AI in generating robust code. After reviewing the initial output from Copilot, you'll refine your prompts to handle edge cases and improve error handling. Finally, you'll validate the generated code by running tests and reviewing the outputs to ensure everything meets your requirements. Follow along with the provided Python examples to reproduce this process in your own projects."
}

For each suggested visual element (3-5 total), provide:
1. Specific description of what to capture
2. Technical requirements (tools, versions, settings)
3. Clear explanation of educational value
4. Step or concept it supports
5. Format recommendation (screenshot, GIF, diagram, etc.)

Ensure all suggestions:
- Match the specified tool versions and environments
- Support key learning objectives
- Can be easily reproduced
- Add genuine educational value

2025-03-06 19:01:17,842 - INFO - ----------------------------------------
2025-03-06 19:01:17,842 - INFO - RESPONSE:
2025-03-06 19:01:17,842 - INFO - ----------------------------------------
2025-03-06 19:01:17,842 - INFO - Here are suggestions for visual elements to enhance learning and comprehension for the use case "Craft Effective Code Prompts for AI Assistance." These visuals focus on tool-specific interactions and technical concepts related to GitHub Copilot and Python programming.

### Visual Element 1: Docstring Composition 
1. **Specific description**: Capture a screenshot of the VS Code editor showing a detailed Python function docstring. Ensure the function includes purpose, parameters, return values, and an example.
2. **Technical requirements**: 
   - Tools: Visual Studio Code
   - Version: Latest version as of October 2023
   - Settings: Python extension enabled for syntax highlighting
3. **Educational value**: Demonstrates how to write comprehensive docstrings, which are crucial for guiding AI tools like GitHub Copilot.
4. **Supports**: Step 1 - "Write detailed function docstring."
5. **Format recommendation**: Screenshot 

### Visual Element 2: Creating TODO Comments
1. **Specific description**: Provide an animated GIF showing the process of adding inline TODO comments in a Python function to outline specific tasks.
2. **Technical requirements**: 
   - Tools: GitHub Copilot integrated with Visual Studio Code
   - Version: Copilot running with GPT-4o support
   - Settings: Inline chat mode enabled
3. **Educational value**: Visualizes how developers can use TODO comments to communicate algorithmic requirements and constraints effectively.
4. **Supports**: Step 2 - "Add specific TODO comments."
5. **Format recommendation**: GIF demonstrating dynamic interaction

### Visual Element 3: Natural Language Logic Description
1. **Specific description**: Diagram illustrating the steps of a complex algorithm (e.g., merge sort) along with plain language explanations.
2. **Technical requirements**: 
   - Tools: Lucidchart or similar diagramming tool
   - Version: Online or desktop version with Python code support options
   - Settings: Use simple graphics to ensure clarity
3. **Educational value**: Breaks down complex logic into understandable steps, facilitating better comprehension and AI guidance.
4. **Supports**: Step 3 - "Describe complex logic in natural language."
5. **Format recommendation**: Flowchart or step-by-step diagram

### Visual Element 4: Refining Prompts and Validating Outputs
1. **Specific description**: Create a split-view screenshot showing both initial AI-generated code and refined code after prompt adjustments in VS Code, highlighting changes with annotations.
2. **Technical requirements**: 
   - Tools: Visual Studio Code with GitHub Copilot enabled
   - Version: Fully updated as of October 2023
   - Settings: Use comparison or diff view if available
3. **Educational value**: Clearly shows the impact of refining prompts on the quality of AI-generated code, emphasizing the iterative improvement process.
4. **Supports**: Step 4 - "Refine your prompts based on initial output."
5. **Format recommendation**: Annotated comparison screenshot 

### Visual Element 5: Testing and Validating Code 
1. **Specific description**: A video screen capture showing the process of running unit tests in a terminal to validate the AI-generated Python code.
2. **Technical requirements**: 
   - Tools: Visual Studio Code, Python's unittest framework
   - Version: Use Python 3.8 or later
   - Settings: Terminal panel open within the IDE
3. **Educational value**: Demonstrates the importance of testing AI-generated code to ensure it meets functional requirements and handles edge cases properly.
4. **Supports**: Step 5 - "Validate the generated code."
5. **Format recommendation**: Short video recording

These visual aids align with the use case guidelines, support learning objectives, and can be readily recreated in the specified environments. They provide both practical insights and enhance conceptual understanding for junior developers learning to use AI-assisted code generation tools like GitHub Copilot.
2025-03-06 19:01:17,842 - INFO - ================================================================================

2025-03-06 19:01:17,843 - INFO - 
Completed step 6: Visual element suggestions

2025-03-06 19:01:17,843 - INFO - 
================= FINAL USE CASE OUTPUT =================

2025-03-06 19:01:17,843 - INFO - {
  "title": "Craft Effective Code Prompts for AI Assistance",
  "time_to_complete": "20 minutes",
  "description": "This use case guides you on how to use AI tools by writing precise comments and docstrings that serve as effective prompts for automated code generation. By following research-backed guidelines, you will learn to create clear, detailed function descriptions and specific TODO comments to express your algorithmic intent. This process highlights the importance of natural language clarity, iterative prompt refinement, and validating AI-generated outputs to ensure they match your original intent.",
  "steps": [
    {
      "step_title": "Write detailed function docstring",
      "step_instructions": "Compose a comprehensive docstring that explains the function's purpose, parameters, return values, and usage examples. Ensure your description is clear and concise to guide the AI effectively.",
      "sub_steps": [
        {
          "title": "Clear function purpose",
          "description": "Begin with a high-level overview of what the function does.",
          "bullets": [
            "Provide a concise summary.",
            "State the main responsibility of the function."
          ]
        },
        {
          "title": "Parameter details",
          "description": "List each parameter with its type, acceptable range, and purpose.",
          "bullets": [
            "Include default values if applicable.",
            "Clarify expected input for each parameter."
          ]
        },
        {
          "title": "Return values",
          "description": "Describe the format and type of the value returned by the function.",
          "bullets": [
            "Indicate any special cases or edge conditions.",
            "Provide clarity on the expected output."
          ]
        }
      ],
      "advice": "Ensure that your docstring adheres to common documentation conventions and serves as a clear prompt for AI code generation."
    },
    {
      "step_title": "Add specific TODO comments",
      "step_instructions": "Insert inline TODO comments that outline specific algorithmic requirements and constraints. Use clear language to define the tasks that need to be completed.",
      "sub_steps": [
        {
          "title": "Specific action items",
          "description": "Detail what needs to be implemented with clear and actionable instructions.",
          "bullets": [
            "List precise tasks to be completed.",
            "Avoid vague descriptions."
          ]
        },
        {
          "title": "Context and constraints",
          "description": "Provide background information and mention any constraints related to the algorithm.",
          "bullets": [
            "Include performance or error handling requirements.",
            "Reference relevant documentation if necessary."
          ]
        }
      ],
      "advice": "Detailed TODO comments guide the AI to generate code that meets your original specifications."
    },
    {
      "step_title": "Describe complex logic in natural language",
      "step_instructions": "Before implementation, write out the logic behind complex parts in plain language to ensure that the AI understands the intended approach.",
      "sub_steps": [
        {
          "title": "Break down the logic",
          "description": "Outline the sequential steps of the algorithm in simple language.",
          "bullets": [
            "Explain the reasoning behind each step.",
            "Detail expected behavior and edge cases."
          ]
        }
      ],
      "advice": "This approach enhances AI understanding and leads to more accurate code generation for complex tasks."
    },
    {
      "step_title": "Refine your prompts based on initial output",
      "step_instructions": "Review the AI-generated code and adjust your prompts by adding more details or clarifications to address any shortcomings.",
      "sub_steps": [
        {
          "title": "Review initial output",
          "description": "Analyze the first version of the generated code to spot any misalignments with your intended functionality.",
          "bullets": [
            "Identify missing features or discrepancies.",
            "Note areas that require more detail."
          ]
        },
        {
          "title": "Iterative improvement",
          "description": "Modify your prompts and comments based on the review to refine the generated output.",
          "bullets": [
            "Incorporate targeted feedback into your comments.",
            "Focus on specific aspects that need clarification."
          ]
        }
      ],
      "advice": "Iterative refinement of your prompts greatly enhances the accuracy and quality of the AI-generated code."
    },
    {
      "step_title": "Validate the generated code",
      "step_instructions": "Test and review the AI-generated code to ensure it meets the functional, quality, and performance requirements.",
      "sub_steps": [
        {
          "title": "Conduct code review",
          "description": "Manually review the code for correctness, readability, and adherence to coding standards.",
          "bullets": [
            "Inspect for any errors or oversights.",
            "Ensure the documentation is complete."
          ]
        },
        {
          "title": "Perform testing",
          "description": "Develop and run test cases to verify that the code works as expected under various scenarios.",
          "bullets": [
            "Use unit tests and integration tests.",
            "Evaluate performance and edge case handling."
          ]
        }
      ],
      "advice": "Thorough validation through review and testing ensures that the AI-generated code aligns perfectly with your original intent."
    }
  ],
  "resources": [
    "https://docs.github.com/en/copilot/using-github-copilot/best-practices-for-using-github-copilot",
    "https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat",
    "https://github.blog/developer-skills/github/how-to-write-better-prompts-for-github-copilot/"
  ],
  "metadata": {
    "id": "CORE-02",
    "title": "Craft Effective Code Prompts for AI Assistance",
    "family": "Core Skills",
    "ai_tool": "Coding Assistants",
    "objective": "Enable developers to effectively communicate programming intent through structured comments that trigger accurate AI code generation",
    "description": "This use case trains developers to harness AI tooling by writing precise comments and docstrings that function as prompts for automated code generation. It emphasizes the importance of natural language clarity in directives (e.g., docstrings and TODOs) and guides participants to refine prompts as needed while validating AI-generated outputs against the original intent.",
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "time_estimate": "20 minutes",
    "steps": [
      "Write a detailed function description in docstring format",
      "Add TODO comments with specific algorithm requirements",
      "Use natural language to describe complex logic before implementation",
      "Refine prompts based on initial AI outputs",
      "Validate generated code against original intent"
    ],
    "tool": "GitHub Copilot",
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "citations": [
    {
      "url": "https://community.openai.com/t/a-guide-to-crafting-effective-prompts-for-diverse-applications/493914",
      "title": "A Guide to Crafting Effective Prompts for Diverse Applications - OpenAI Developer Community",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://mitsloanedtech.mit.edu/ai/basics/effective-prompts/",
      "title": "Effective Prompts for AI: The Essentials - MIT Sloan Teaching & Learning Technologies",
      "snippet": null,
      "relevance_score": 0.9
    },
    {
      "url": "https://leaddev.com/velocity/how-write-better-ai-prompts",
      "title": "How to write better AI prompts - LeadDev",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://hatchworks.com/blog/gen-ai/generative-ai-prompt-guide/",
      "title": "Expert\u2019s Guide: Generative AI Prompts for Maximum Efficiency",
      "snippet": null,
      "relevance_score": 0.85
    },
    {
      "url": "https://www.codecademy.com/article/ai-prompting-best-practices",
      "title": "AI Prompting Best Practices | Codecademy",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://codesignal.com/learn/courses/clean-code-basics-with-python/lessons/comments-and-documentation-in-python",
      "title": "Comments and Documentation in Python | CodeSignal Learn",
      "snippet": null,
      "relevance_score": 0.75
    },
    {
      "url": "https://www.sonarsource.com/learn/ai-code-generation-benefits-risks/",
      "title": "AI Code Generation Benefits & Risks | Sonar",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://www.huit.harvard.edu/news/ai-prompts",
      "title": "Getting started with prompts for text-based Generative AI tools | Harvard University Information Technology",
      "snippet": null,
      "relevance_score": 0.8
    },
    {
      "url": "https://www.youtube.com/watch?v=aviT9zbqF5o",
      "title": "Validating AI-Generated Code with Live Programming - YouTube",
      "snippet": null,
      "relevance_score": 0.7
    },
    {
      "url": "https://dev.to/bsorrentino/genaiscript-comment-code-with-ai-509f",
      "title": "GenAIScript - Comment Code with AI - DEV Community",
      "snippet": null,
      "relevance_score": 0.75
    }
  ]
}
2025-03-06 19:01:17,843 - INFO - 
================= EXAMPLE SOLUTION =================

2025-03-06 19:01:17,844 - INFO - {
  "metadata": {
    "id": "CORE-02",
    "ai_tool": "GitHub Copilot",
    "family": "Core Skills",
    "status": "active",
    "complexity_level": "Intermediate",
    "customization_level": "Standard",
    "time_minutes": 20,
    "department": [
      "SWE"
    ],
    "role": [
      "front-end"
    ],
    "notes": "This solution demonstrates effective code prompting in an inline chat environment using GitHub Copilot with GPT-4o.",
    "tool": "GitHub Copilot",
    "mode": "inline chat",
    "model": "GPT-4o",
    "coding_language": "Python"
  },
  "solution": {
    "title": "Craft Effective Code Prompts for AI Assistance",
    "setup_time": 3,
    "demo_time": 3,
    "prerequisites": [
      "Writing clear code comments",
      "Understanding code structure",
      "Basic algorithmic thinking",
      "Familiarity with code completion tools",
      "Basic understanding of natural language processing"
    ],
    "scenario": "A front-end developer utilizes GitHub Copilot in inline chat mode powered by GPT-4o to iteratively generate and improve Python code. The developer writes detailed docstrings, adds specific TODO comments, clearly explains complex logic in plain language, refines prompts based on initial outputs, and validates the final code through testing.",
    "steps": [
      {
        "action": "Write detailed function docstring: Compose a comprehensive Python function docstring that details the function's purpose, parameters, return values, and usage examples to guide the AI.",
        "code_or_prompt": "def calculate_discounted_price(price, discount):\n    \"\"\"\n    Calculate the final price after applying a discount.\n\n    Parameters:\n        price (float): The original price of the item. Must be non-negative.\n        discount (float): Discount rate as a float between 0 and 1 (e.g., 0.20 for 20% discount).\n\n    Returns:\n        float: Final price after discount. Returns 0 if discount is 1.\n\n    Example:\n        >>> calculate_discounted_price(100.0, 0.2)\n        80.0\n    \"\"\"\n    return price * (1 - discount)"
      },
      {
        "action": "Add specific TODO comments: Insert inline TODO comments that clearly outline specific algorithmic tasks and constraints.",
        "code_or_prompt": "def fetch_user_data(user_id: int) -> dict:\n    \"\"\"Fetch user data from the database using a unique user ID.\"\"\"\n    # TODO: Establish a secure connection to the user database\n    # TODO: Execute an SQL query to retrieve user details\n    # TODO: Implement error handling for connection timeouts and query failures\n    # TODO: Validate the format of the returned data\n    return {}"
      },
      {
        "action": "Describe complex logic in natural language: Explain the detailed logic behind a function in plain language to ensure clarity before implementation.",
        "code_or_prompt": "def sort_numbers(numbers: list) -> list:\n    \"\"\"Sort a list of numbers using the merge sort algorithm.\"\"\"\n    # The merge sort algorithm works as follows:\n    # 1. If the list has zero or one element, it is already sorted.\n    # 2. Divide the list into two nearly equal halves.\n    # 3. Recursively sort each half.\n    # 4. Merge the two sorted halves by comparing the smallest elements from each.\n    # 5. Return the fully merged and sorted list.\n    if len(numbers) <= 1:\n        return numbers\n    mid = len(numbers) // 2\n    left = sort_numbers(numbers[:mid])\n    right = sort_numbers(numbers[mid:])\n    sorted_list = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n    return sorted_list"
      },
      {
        "action": "Refine your prompts based on initial output: Review the AI-generated code and adjust your prompts with added clarifications for error handling and edge cases.",
        "code_or_prompt": "# Initial review of the fetch_user_data function revealed missing input validation and error handling for invalid user IDs.\n# Refined prompt for GitHub Copilot:\n\"@copilot, update the fetch_user_data function to include validation that the user_id is a positive integer and add try-except blocks to handle potential database errors.\""
      },
      {
        "action": "Validate the generated code: Test and review the code to ensure it meets functional requirements and handles edge cases appropriately.",
        "code_or_prompt": "if __name__ == '__main__':\n    # Validate calculate_discounted_price function\n    result = calculate_discounted_price(100.0, 0.2)\n    print('Discounted Price:', result)  # Expected output: 80.0\n\n    # Validate sort_numbers function\n    test_numbers = [34, 7, 23, 32, 5, 62]\n    sorted_numbers = sort_numbers(test_numbers)\n    print('Sorted Numbers:', sorted_numbers)  # Expected sorted list: [5, 7, 23, 32, 34, 62]\n\n    # Further testing and manual code review should be performed to ensure all edge cases and error handling are in place."
      }
    ],
    "validation": [
      "Run the main block to verify the expected outputs for each function.",
      "Inspect inline comments and TODO items to confirm they guide the AI effectively.",
      "Verify that GitHub Copilot's refined suggestions address initial shortcomings.",
      "Conduct manual code reviews and run unit tests to cover error handling and edge cases."
    ],
    "key_points": [
      "Craft clear and comprehensive docstrings as effective AI prompts.",
      "Include specific and actionable TODO comments.",
      "Describe complex logic in plain natural language.",
      "Iteratively refine prompts based on AI output feedback.",
      "Validate generated code through thorough testing and reviews."
    ],
    "common_issues": [
      "Ambiguous prompts may not capture all functional requirements.",
      "Overreliance on auto-generated code without manual validation.",
      "Insufficient error handling or unclear TODO instructions.",
      "Missing detailed inline explanations can reduce code clarity."
    ],
    "variations": []
  },
  "demo_script": "Welcome to this demo on crafting effective code prompts for AI assistance using GitHub Copilot with GPT-4o. In this 2-3 minute walkthrough, you'll see how to start by writing a detailed function docstring that defines a function's purpose, parameters, and return values. Next, you'll add specific TODO comments that precisely outline each task and constraint. We'll then describe complex logic in plain language to guide the AI in generating robust code. After reviewing the initial output from Copilot, you'll refine your prompts to handle edge cases and improve error handling. Finally, you'll validate the generated code by running tests and reviewing the outputs to ensure everything meets your requirements. Follow along with the provided Python examples to reproduce this process in your own projects."
}
2025-03-06 19:01:17,846 - INFO - 
================= VISUAL SUGGESTIONS =================

2025-03-06 19:01:17,846 - INFO - Here are suggestions for visual elements to enhance learning and comprehension for the use case "Craft Effective Code Prompts for AI Assistance." These visuals focus on tool-specific interactions and technical concepts related to GitHub Copilot and Python programming.

### Visual Element 1: Docstring Composition 
1. **Specific description**: Capture a screenshot of the VS Code editor showing a detailed Python function docstring. Ensure the function includes purpose, parameters, return values, and an example.
2. **Technical requirements**: 
   - Tools: Visual Studio Code
   - Version: Latest version as of October 2023
   - Settings: Python extension enabled for syntax highlighting
3. **Educational value**: Demonstrates how to write comprehensive docstrings, which are crucial for guiding AI tools like GitHub Copilot.
4. **Supports**: Step 1 - "Write detailed function docstring."
5. **Format recommendation**: Screenshot 

### Visual Element 2: Creating TODO Comments
1. **Specific description**: Provide an animated GIF showing the process of adding inline TODO comments in a Python function to outline specific tasks.
2. **Technical requirements**: 
   - Tools: GitHub Copilot integrated with Visual Studio Code
   - Version: Copilot running with GPT-4o support
   - Settings: Inline chat mode enabled
3. **Educational value**: Visualizes how developers can use TODO comments to communicate algorithmic requirements and constraints effectively.
4. **Supports**: Step 2 - "Add specific TODO comments."
5. **Format recommendation**: GIF demonstrating dynamic interaction

### Visual Element 3: Natural Language Logic Description
1. **Specific description**: Diagram illustrating the steps of a complex algorithm (e.g., merge sort) along with plain language explanations.
2. **Technical requirements**: 
   - Tools: Lucidchart or similar diagramming tool
   - Version: Online or desktop version with Python code support options
   - Settings: Use simple graphics to ensure clarity
3. **Educational value**: Breaks down complex logic into understandable steps, facilitating better comprehension and AI guidance.
4. **Supports**: Step 3 - "Describe complex logic in natural language."
5. **Format recommendation**: Flowchart or step-by-step diagram

### Visual Element 4: Refining Prompts and Validating Outputs
1. **Specific description**: Create a split-view screenshot showing both initial AI-generated code and refined code after prompt adjustments in VS Code, highlighting changes with annotations.
2. **Technical requirements**: 
   - Tools: Visual Studio Code with GitHub Copilot enabled
   - Version: Fully updated as of October 2023
   - Settings: Use comparison or diff view if available
3. **Educational value**: Clearly shows the impact of refining prompts on the quality of AI-generated code, emphasizing the iterative improvement process.
4. **Supports**: Step 4 - "Refine your prompts based on initial output."
5. **Format recommendation**: Annotated comparison screenshot 

### Visual Element 5: Testing and Validating Code 
1. **Specific description**: A video screen capture showing the process of running unit tests in a terminal to validate the AI-generated Python code.
2. **Technical requirements**: 
   - Tools: Visual Studio Code, Python's unittest framework
   - Version: Use Python 3.8 or later
   - Settings: Terminal panel open within the IDE
3. **Educational value**: Demonstrates the importance of testing AI-generated code to ensure it meets functional requirements and handles edge cases properly.
4. **Supports**: Step 5 - "Validate the generated code."
5. **Format recommendation**: Short video recording

These visual aids align with the use case guidelines, support learning objectives, and can be readily recreated in the specified environments. They provide both practical insights and enhance conceptual understanding for junior developers learning to use AI-assisted code generation tools like GitHub Copilot.
2025-03-06 19:01:17,847 - INFO - 
=========================================================

2025-03-06 19:01:17,848 - INFO - 
Job completed: craft_effective_code_prompts_for_ai_assistance_20250306_185813
2025-03-06 19:01:17,848 - INFO - Results stored in: /Users/caseybates/thinkfox-ai/multiverse_use_cases/use_cases/craft_effective_code_prompts_for_ai_assistance_20250306_185813
