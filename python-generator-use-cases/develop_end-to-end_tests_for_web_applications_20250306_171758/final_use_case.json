{
  "content": "{\n  \"title\": \"Develop End-to-End Tests for Web Applications\",\n  \"time_to_complete\": \"25 minutes\",\n  \"description\": \"Create comprehensive tests that simulate user interactions across entire web pages or flows. Leverage GitHub Copilot and Claude Sonnet 3.7 to develop tests that ensure overall functionality and user experience, and catch integration issues that unit tests might miss.\",\n  \"steps\": [\n    {\n      \"step_title\": \"Define test scenarios and user flows\",\n      \"step_instructions\": \"Outline your key user interactions and potential edge cases in natural language to build a robust foundation for AI-generated tests.\",\n      \"sub_steps\": [\n        {\n          \"title\": \"Identify primary flows and edge cases\",\n          \"description\": null,\n          \"bullets\": [\n            \"List key user actions like login, adding items to a cart, and checkout\",\n            \"Document potential error scenarios such as network issues or invalid inputs\"\n          ]\n        }\n      ],\n      \"advice\": \"Use clear, concise language to help the AI accurately capture your application's behavior.\"\n    },\n    {\n      \"step_title\": \"Generate initial test structure\",\n      \"step_instructions\": \"Utilize GitHub Copilot and Claude Sonnet 3.7 to create a foundational test skeleton that covers the entire user journey.\",\n      \"sub_steps\": [\n        {\n          \"title\": \"Invoke inline code suggestions\",\n          \"description\": \"Leverage GitHub Copilot to generate function definitions and boilerplate code, while using Claude Sonnet 3.7 for complex flow handling.\",\n          \"bullets\": [\n            \"Generate basic test scaffolding automatically\",\n            \"Iteratively refine the structure based on your application context\"\n          ]\n        }\n      ],\n      \"advice\": \"Review and adjust the AI-generated structure to ensure it matches your requirements.\"\n    },\n    {\n      \"step_title\": \"Develop comprehensive test scripts\",\n      \"step_instructions\": \"Write complete test cases using your chosen testing framework (e.g., Playwright or Cypress) to simulate detailed user interactions.\",\n      \"sub_steps\": [\n        {\n          \"title\": \"Implement user interaction steps\",\n          \"description\": null,\n          \"bullets\": [\n            \"Include navigation, form inputs, button clicks, and assertion checks\",\n            \"Validate UI elements, API responses, and local storage as needed\"\n          ]\n        },\n        {\n          \"title\": \"Incorporate robust error handling\",\n          \"description\": null,\n          \"bullets\": [\n            \"Add try/catch blocks and assertions for error scenarios\",\n            \"Log unexpected errors for debugging\"\n          ]\n        }\n      ],\n      \"advice\": \"Combine AI-generated code with manual verification to cover all critical pathways.\"\n    },\n    {\n      \"step_title\": \"Validate and enhance AI-generated tests\",\n      \"step_instructions\": \"Review the generated tests for accuracy, then manually test for edge cases and integration points that may not be fully covered.\",\n      \"sub_steps\": [\n        {\n          \"title\": \"Test for missing scenarios\",\n          \"description\": null,\n          \"bullets\": [\n            \"Check for timeouts, invalid credentials, and UI changes\",\n            \"Include API call validations and database state checks\"\n          ]\n        },\n        {\n          \"title\": \"Refine tests using AI feedback\",\n          \"description\": null,\n          \"bullets\": [\n            \"Iterate based on manual testing results\",\n            \"Leverage additional AI suggestions to update tests dynamically\"\n          ]\n        }\n      ],\n      \"advice\": \"Continuous review and adjustment ensure that your tests remain effective as the application evolves.\"\n    },\n    {\n      \"step_title\": \"Optimize and integrate tests\",\n      \"step_instructions\": \"Refactor test code for performance and maintainability, then integrate the tests into your CI/CD pipeline for automated execution.\",\n      \"sub_steps\": [\n        {\n          \"title\": \"Optimize test performance\",\n          \"description\": null,\n          \"bullets\": [\n            \"Implement parallel test execution where possible\",\n            \"Reduce redundant setup and teardown operations\"\n          ]\n        },\n        {\n          \"title\": \"Integrate with CI/CD\",\n          \"description\": null,\n          \"bullets\": [\n            \"Set up automated test runs on code changes\",\n            \"Monitor test results to quickly address failures\"\n          ]\n        }\n      ],\n      \"advice\": \"Regularly update and refactor your test suite to adapt to changes in the application.\"\n    }\n  ],\n  \"resources\": [\n    \"https://docs.github.com/en/copilot/copilot-chat-cookbook/testing-code/create-end-to-end-tests-for-a-webpage\",\n    \"https://docs.github.com/en/copilot/using-github-copilot/ai-models/using-claude-sonnet-in-github-copilot\"\n  ],\n  \"metadata\": {\n    \"id\": \"\",\n    \"title\": \"Develop End-to-End Tests for Web Applications\",\n    \"family\": \"Core Skills\",\n    \"ai_tool\": \"Coding Assistants\",\n    \"objective\": \"Leverage GitHub Copilot and Claude Sonnet 3.7 to develop comprehensive end-to-end tests for web applications, ensuring overall functionality and user experience, catching integration issues that unit tests might miss.\",\n    \"description\": \"Create comprehensive tests that simulate user interactions across entire web pages or flows. This use case ensures the overall functionality and user experience of web applications, catching integration issues that unit tests might miss.\",\n    \"prerequisites\": [\n      \"Writing clear code comments\",\n      \"Understanding code structure\",\n      \"Basic algorithmic thinking\",\n      \"Familiarity with code completion tools\",\n      \"Basic understanding of natural language processing\"\n    ],\n    \"time_estimate\": \"25 minutes\",\n    \"steps\": [],\n    \"tool\": \"GitHub Copilot\",\n    \"department\": [\n      \"SWE\"\n    ],\n    \"role\": [\n      \"agnostic\"\n    ],\n    \"mode\": \"agentic\",\n    \"model\": \"claude-sonnet-3.7\",\n    \"coding_language\": \"agnostic\"\n  },\n  \"citations\": [\n    {\n      \"url\": \"https://apidog.com/blog/claude-3-7-sonnet-api/\",\n      \"title\": \"How to Access Claude 3.7 Sonnet API and Test Using Apidog\",\n      \"snippet\": null,\n      \"relevance_score\": 0.75\n    },\n    {\n      \"url\": \"https://www.frugaltesting.com/blog/automate-your-tests-with-github-copilot-a-step-by-step-guide\",\n      \"title\": \"Automate Your Tests with GitHub Copilot: A Step-by-Step Guide\",\n      \"snippet\": null,\n      \"relevance_score\": 0.8\n    },\n    {\n      \"url\": \"https://www.youtube.com/watch?v=LHVLyqc_WBM\",\n      \"title\": \"Demo: Using Claude 3.7 Sonnet with GitHub Copilot - YouTube\",\n      \"snippet\": null,\n      \"relevance_score\": 0.7\n    },\n    {\n      \"url\": \"https://www.headspin.io/blog/what-is-end-to-end-testing\",\n      \"title\": \"What is End-to-End Testing? - A Complete Guide for E2E Testing\",\n      \"snippet\": null,\n      \"relevance_score\": 0.75\n    },\n    {\n      \"url\": \"https://www.transcenda.com/insights/technical-approaches-and-frameworks-for-end-to-end-testing-of-web-apps\",\n      \"title\": \"End-to-End Web App Testing | Transcenda\",\n      \"snippet\": null,\n      \"relevance_score\": 0.8\n    },\n    {\n      \"url\": \"https://katalon.com/resources-center/blog/end-to-end-e2e-testing\",\n      \"title\": \"What is End To End Testing? Definition, Tools, Best Practices\",\n      \"snippet\": null,\n      \"relevance_score\": 0.75\n    },\n    {\n      \"url\": \"https://www.octomind.dev/blog/keep-your-copilot-and-your-code-quality-with-ai-testing\",\n      \"title\": \"AI testing: Keep your copilot and your code quality\",\n      \"snippet\": null,\n      \"relevance_score\": 0.7\n    }\n  ]\n}"
}